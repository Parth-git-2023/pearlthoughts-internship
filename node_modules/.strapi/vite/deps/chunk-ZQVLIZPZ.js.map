{
  "version": 3,
  "sources": ["../../../../../packages/core/content-manager/admin/src/constants/collections.ts", "../../../../../packages/core/content-manager/admin/src/pages/EditView/utils/data.ts", "../../../../../packages/core/content-manager/admin/src/constants/attributes.ts", "../../../../../packages/core/content-manager/admin/src/services/documents.ts", "../../../../../packages/core/content-manager/admin/src/utils/api.ts", "../../../../../packages/core/content-manager/admin/src/utils/validation.ts", "../../../../../packages/core/content-manager/admin/src/services/init.ts", "../../../../../packages/core/content-manager/admin/src/hooks/useContentTypeSchema.ts", "../../../../../packages/core/content-manager/admin/src/constants/hooks.ts", "../../../../../packages/core/content-manager/admin/src/services/contentTypes.ts", "../../../../../packages/core/content-manager/admin/src/hooks/useDocumentLayout.ts", "../../../../../packages/core/content-manager/admin/src/utils/attributes.ts", "../../../../../packages/core/content-manager/admin/src/hooks/useDocument.ts", "../../../../../packages/core/content-manager/admin/src/pages/EditView/utils/forms.ts", "../../../../../packages/core/content-manager/admin/src/utils/objects.ts"],
  "sourcesContent": ["const SINGLE_TYPES = 'single-types';\r\nconst COLLECTION_TYPES = 'collection-types';\r\n\r\nexport { SINGLE_TYPES, COLLECTION_TYPES };\r\n", "import { createRulesEngine } from '@strapi/admin/strapi-admin';\r\nimport { generateNKeysBetween } from 'fractional-indexing';\r\nimport pipe from 'lodash/fp/pipe';\r\n\r\nimport { DOCUMENT_META_FIELDS } from '../../../constants/attributes';\r\n\r\nimport type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\r\nimport type { Schema, UID } from '@strapi/types';\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * traverseData\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n// Make only attributes required since it's the only one Content History has\r\ntype PartialSchema = Partial<Schema.Schema> & Pick<Schema.Schema, 'attributes'>;\r\n\r\ntype Predicate = <TAttribute extends Schema.Attribute.AnyAttribute>(\r\n  attribute: TAttribute,\r\n  value: Schema.Attribute.Value<TAttribute>\r\n) => boolean;\r\ntype Transform = <TAttribute extends Schema.Attribute.AnyAttribute>(\r\n  value: any,\r\n  attribute: TAttribute\r\n) => any;\r\ntype AnyData = Omit<Document, 'id'>;\r\n\r\nconst BLOCK_LIST_ATTRIBUTE_KEYS = ['__component', '__temp_key__'];\r\n\r\n/**\r\n * @internal This function is used to traverse the data and transform the values.\r\n * Given a predicate function, it will transform the value (using the given transform function)\r\n * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,\r\n * it will recursively traverse those data structures as well.\r\n *\r\n * It is possible to break the ContentManager by using this function incorrectly, for example,\r\n * if you transform a number into a string but the attribute type is a number, the ContentManager\r\n * will not be able to save the data and the Form will likely crash because the component it's\r\n * passing the data too won't succesfully be able to handle the value.\r\n */\r\nconst traverseData =\r\n  (predicate: Predicate, transform: Transform) =>\r\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\r\n  (data: AnyData = {}) => {\r\n    const traverse = (datum: AnyData, attributes: Schema.Schema['attributes']) => {\r\n      return Object.entries(datum).reduce<AnyData>((acc, [key, value]) => {\r\n        const attribute = attributes[key];\r\n\r\n        /**\r\n         * If the attribute is a block list attribute, we don't want to transform it.\r\n         * We also don't want to transform null or undefined values.\r\n         */\r\n        if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {\r\n          acc[key] = value;\r\n          return acc;\r\n        }\r\n\r\n        if (attribute.type === 'component') {\r\n          if (attribute.repeatable) {\r\n            const componentValue = (\r\n              predicate(attribute, value) ? transform(value, attribute) : value\r\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\r\n            acc[key] = componentValue.map((componentData) =>\r\n              traverse(componentData, components[attribute.component]?.attributes ?? {})\r\n            );\r\n          } else {\r\n            const componentValue = (\r\n              predicate(attribute, value) ? transform(value, attribute) : value\r\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, false>>;\r\n\r\n            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});\r\n          }\r\n        } else if (attribute.type === 'dynamiczone') {\r\n          const dynamicZoneValue = (\r\n            predicate(attribute, value) ? transform(value, attribute) : value\r\n          ) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\r\n\r\n          acc[key] = dynamicZoneValue.map((componentData) =>\r\n            traverse(componentData, components[componentData.__component]?.attributes ?? {})\r\n          );\r\n        } else if (predicate(attribute, value)) {\r\n          acc[key] = transform(value, attribute);\r\n        } else {\r\n          acc[key] = value;\r\n        }\r\n\r\n        return acc;\r\n      }, {});\r\n    };\r\n\r\n    return traverse(data, schema.attributes);\r\n  };\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * removeProhibitedFields\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal Removes all the fields that are not allowed.\r\n */\r\nconst removeProhibitedFields = (prohibitedFields: Schema.Attribute.Kind[]) =>\r\n  traverseData(\r\n    (attribute) => prohibitedFields.includes(attribute.type),\r\n    () => ''\r\n  );\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * prepareRelations\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal\r\n * @description Sets all relation values to an empty array.\r\n */\r\nconst prepareRelations = traverseData(\r\n  (attribute) => attribute.type === 'relation',\r\n  () => ({\r\n    connect: [],\r\n    disconnect: [],\r\n  })\r\n);\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * prepareTempKeys\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal\r\n * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us\r\n * a stable identifier regardless of its ids etc. that we can then use for drag and drop.\r\n */\r\nconst prepareTempKeys = traverseData(\r\n  (attribute) =>\r\n    (attribute.type === 'component' && attribute.repeatable) || attribute.type === 'dynamiczone',\r\n  (data) => {\r\n    if (Array.isArray(data) && data.length > 0) {\r\n      const keys = generateNKeysBetween(undefined, undefined, data.length);\r\n\r\n      return data.map((datum, index) => ({\r\n        ...datum,\r\n        __temp_key__: keys[index],\r\n      }));\r\n    }\r\n\r\n    return data;\r\n  }\r\n);\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * removeFieldsThatDontExistOnSchema\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal\r\n * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),\r\n * as such we don't need to traverse the components to remove them.\r\n */\r\nconst removeFieldsThatDontExistOnSchema = (schema: PartialSchema) => (data: AnyData) => {\r\n  const schemaKeys = Object.keys(schema.attributes);\r\n  const dataKeys = Object.keys(data);\r\n\r\n  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));\r\n\r\n  const revisedData = [...keysToRemove, ...DOCUMENT_META_FIELDS].reduce((acc, key) => {\r\n    delete acc[key];\r\n\r\n    return acc;\r\n  }, structuredClone(data));\r\n\r\n  return revisedData;\r\n};\r\n\r\n/**\r\n * @internal\r\n * @description We need to remove null fields from the data-structure because it will pass it\r\n * to the specific inputs breaking them as most would prefer empty strings or `undefined` if\r\n * they're controlled / uncontrolled.\r\n */\r\nconst removeNullValues = (data: AnyData) => {\r\n  return Object.entries(data).reduce<AnyData>((acc, [key, value]) => {\r\n    if (value === null) {\r\n      return acc;\r\n    }\r\n\r\n    acc[key] = value;\r\n\r\n    return acc;\r\n  }, {});\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * transformDocuments\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal\r\n * @description Takes a document data structure (this could be from the API or a default form structure)\r\n * and applies consistent data transformations to it. This is also used when we add new components to the\r\n * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.\r\n */\r\nconst transformDocument =\r\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\r\n  (document: AnyData) => {\r\n    const transformations = pipe(\r\n      removeFieldsThatDontExistOnSchema(schema),\r\n      removeProhibitedFields(['password'])(schema, components),\r\n      removeNullValues,\r\n      prepareRelations(schema, components),\r\n      prepareTempKeys(schema, components)\r\n    );\r\n\r\n    return transformations(document);\r\n  };\r\n\r\ntype HandleOptions = {\r\n  schema?: Schema.ContentType | Schema.Component;\r\n  initialValues?: AnyData;\r\n  components?: Record<string, Schema.Component>;\r\n};\r\n\r\ntype RemovedFieldPath = string;\r\n\r\n/**\r\n * Removes values from the data object if their corresponding attribute has a\r\n * visibility condition that evaluates to false.\r\n *\r\n * @param {object} schema - The content type schema (with attributes).\r\n * @param {object} data - The data object to filter based on visibility.\r\n * @returns {object} A new data object with only visible fields retained.\r\n */\r\nconst handleInvisibleAttributes = (\r\n  data: AnyData,\r\n  { schema, initialValues = {}, components = {} }: HandleOptions,\r\n  path: string[] = [],\r\n  removedAttributes: RemovedFieldPath[] = []\r\n): {\r\n  data: AnyData;\r\n  removedAttributes: RemovedFieldPath[];\r\n} => {\r\n  if (!schema?.attributes) return { data, removedAttributes };\r\n\r\n  const rulesEngine = createRulesEngine();\r\n  const result: AnyData = {};\r\n\r\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\r\n    const fullPath = [...path, attrName].join('.');\r\n    const condition = attrDef?.conditions?.visible;\r\n    const isVisible = condition ? rulesEngine.evaluate(condition, { ...data, ...result }) : true;\r\n\r\n    if (!isVisible) {\r\n      removedAttributes.push(fullPath);\r\n      continue;\r\n    }\r\n\r\n    const userProvided = Object.prototype.hasOwnProperty.call(data, attrName);\r\n    const currentValue = userProvided ? data[attrName] : undefined;\r\n    const initialValue = initialValues?.[attrName];\r\n\r\n    // ðŸ”¹ Handle components\r\n    if (attrDef.type === 'component') {\r\n      const compSchema = components[attrDef.component];\r\n      const value = currentValue ?? initialValue;\r\n\r\n      if (!value) {\r\n        result[attrName] = attrDef.repeatable ? [] : null;\r\n        continue;\r\n      }\r\n\r\n      if (attrDef.repeatable && Array.isArray(value)) {\r\n        result[attrName] = value.map(\r\n          (item, index) =>\r\n            handleInvisibleAttributes(\r\n              item,\r\n              {\r\n                schema: compSchema,\r\n                initialValues: initialValue?.[index] ?? {},\r\n                components,\r\n              },\r\n              [...path, `${attrName}[${index}]`],\r\n              removedAttributes\r\n            ).data\r\n        );\r\n      } else {\r\n        result[attrName] = handleInvisibleAttributes(\r\n          value,\r\n          {\r\n            schema: compSchema,\r\n            initialValues: initialValue ?? {},\r\n            components,\r\n          },\r\n          [...path, attrName],\r\n          removedAttributes\r\n        ).data;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    // ðŸ”¸ Handle dynamic zones\r\n    if (attrDef.type === 'dynamiczone') {\r\n      if (!Array.isArray(currentValue)) {\r\n        result[attrName] = [];\r\n        continue;\r\n      }\r\n\r\n      result[attrName] = currentValue.map((dzItem, index) => {\r\n        const compUID = dzItem?.__component;\r\n        const compSchema = components[compUID];\r\n\r\n        const cleaned = handleInvisibleAttributes(\r\n          dzItem,\r\n          {\r\n            schema: compSchema,\r\n            initialValues: initialValue?.[index] ?? {},\r\n            components,\r\n          },\r\n          [...path, `${attrName}[${index}]`],\r\n          removedAttributes\r\n        ).data;\r\n\r\n        return {\r\n          __component: compUID,\r\n          ...cleaned,\r\n        };\r\n      });\r\n\r\n      continue;\r\n    }\r\n\r\n    // ðŸŸ¡ Handle scalar/primitive\r\n    if (currentValue !== undefined) {\r\n      result[attrName] = currentValue;\r\n    } else if (initialValue !== undefined) {\r\n      result[attrName] = initialValue;\r\n    } else {\r\n      if (attrName === 'id' || attrName === 'documentId') {\r\n        // If the attribute is 'id', we don't want to set it to null, as it should not be removed.\r\n        continue;\r\n      }\r\n      result[attrName] = null;\r\n    }\r\n  }\r\n\r\n  return {\r\n    data: result,\r\n    removedAttributes,\r\n  };\r\n};\r\n\r\nexport {\r\n  removeProhibitedFields,\r\n  prepareRelations,\r\n  prepareTempKeys,\r\n  removeFieldsThatDontExistOnSchema,\r\n  transformDocument,\r\n  handleInvisibleAttributes,\r\n};\r\nexport type { AnyData };\r\n", "const ID = 'id';\r\n\r\nconst CREATED_BY_ATTRIBUTE_NAME = 'createdBy';\r\nconst UPDATED_BY_ATTRIBUTE_NAME = 'updatedBy';\r\n\r\nconst CREATOR_FIELDS = [CREATED_BY_ATTRIBUTE_NAME, UPDATED_BY_ATTRIBUTE_NAME];\r\n\r\nconst PUBLISHED_BY_ATTRIBUTE_NAME = 'publishedBy';\r\nconst CREATED_AT_ATTRIBUTE_NAME = 'createdAt';\r\nconst UPDATED_AT_ATTRIBUTE_NAME = 'updatedAt';\r\nconst PUBLISHED_AT_ATTRIBUTE_NAME = 'publishedAt';\r\n\r\nconst DOCUMENT_META_FIELDS = [\r\n  ID,\r\n  ...CREATOR_FIELDS,\r\n  PUBLISHED_BY_ATTRIBUTE_NAME,\r\n  CREATED_AT_ATTRIBUTE_NAME,\r\n  UPDATED_AT_ATTRIBUTE_NAME,\r\n  PUBLISHED_AT_ATTRIBUTE_NAME,\r\n];\r\n\r\n/**\r\n * List of attribute types that cannot be used as the main field.\r\n * Not sure the name could be any clearer.\r\n */\r\nconst ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD = [\r\n  'dynamiczone',\r\n  'json',\r\n  'text',\r\n  'relation',\r\n  'component',\r\n  'boolean',\r\n  'media',\r\n  'password',\r\n  'richtext',\r\n  'timestamp',\r\n  'blocks',\r\n];\r\n\r\nexport {\r\n  ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD,\r\n  CREATED_AT_ATTRIBUTE_NAME,\r\n  UPDATED_AT_ATTRIBUTE_NAME,\r\n  PUBLISHED_AT_ATTRIBUTE_NAME,\r\n  CREATED_BY_ATTRIBUTE_NAME,\r\n  UPDATED_BY_ATTRIBUTE_NAME,\r\n  PUBLISHED_BY_ATTRIBUTE_NAME,\r\n  CREATOR_FIELDS,\r\n  DOCUMENT_META_FIELDS,\r\n};\r\n", "/**\r\n * Related to fetching the actual content of a collection type or single type.\r\n */\r\nimport { stringify } from 'qs';\r\n\r\nimport { SINGLE_TYPES } from '../constants/collections';\r\n\r\nimport { contentManagerApi } from './api';\r\n\r\nimport type {\r\n  Clone,\r\n  Create,\r\n  Delete,\r\n  Find,\r\n  FindOne,\r\n  BulkDelete,\r\n  BulkPublish,\r\n  BulkUnpublish,\r\n  Discard,\r\n  CountDraftRelations,\r\n  CountManyEntriesDraftRelations,\r\n  Publish,\r\n  Unpublish,\r\n  Update,\r\n} from '../../../shared/contracts/collection-types';\r\n\r\nconst documentApi = contentManagerApi.injectEndpoints({\r\n  overrideExisting: true,\r\n  endpoints: (builder) => ({\r\n    autoCloneDocument: builder.mutation<\r\n      Clone.Response,\r\n      Clone.Params & {\r\n        params?: Find.Request['query'] & Clone.Request['query'];\r\n      }\r\n    >({\r\n      query: ({ model, sourceId, params }) => ({\r\n        url: `/content-manager/collection-types/${model}/auto-clone/${sourceId}`,\r\n        method: 'POST',\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_result, error, { model }) => {\r\n        if (error) {\r\n          return [];\r\n        }\r\n\r\n        return [{ type: 'Document', id: `${model}_LIST` }, 'RecentDocumentList', 'CountDocuments'];\r\n      },\r\n    }),\r\n    cloneDocument: builder.mutation<\r\n      Clone.Response,\r\n      Clone.Params & {\r\n        data: Clone.Request['body'];\r\n        params?: Clone.Request['query'];\r\n      }\r\n    >({\r\n      query: ({ model, sourceId, data, params }) => ({\r\n        url: `/content-manager/collection-types/${model}/clone/${sourceId}`,\r\n        method: 'POST',\r\n        data,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_result, _error, { model }) => [\r\n        { type: 'Document', id: `${model}_LIST` },\r\n        { type: 'UidAvailability', id: model },\r\n        'RecentDocumentList',\r\n        'CountDocuments',\r\n      ],\r\n    }),\r\n    /**\r\n     * Creates a new collection-type document. This should ONLY be used for collection-types.\r\n     * single-types should always be using `updateDocument` since they always exist.\r\n     */\r\n    createDocument: builder.mutation<\r\n      Create.Response,\r\n      Create.Params & {\r\n        data: Create.Request['body'];\r\n        params?: Create.Request['query'];\r\n      }\r\n    >({\r\n      query: ({ model, data, params }) => ({\r\n        url: `/content-manager/collection-types/${model}`,\r\n        method: 'POST',\r\n        data,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (result, _error, { model }) => [\r\n        { type: 'Document', id: `${model}_LIST` },\r\n        'Relations',\r\n        { type: 'UidAvailability', id: model },\r\n        'RecentDocumentList',\r\n        'CountDocuments',\r\n      ],\r\n      transformResponse: (response: Create.Response, meta, arg): Create.Response => {\r\n        /**\r\n         * TODO v6\r\n         * Adapt plugin:users-permissions.user to return the same response\r\n         * shape as all other requests. The error is returned as expected.\r\n         */\r\n        if (!('data' in response) && arg.model === 'plugin::users-permissions.user') {\r\n          return {\r\n            data: response,\r\n            meta: {\r\n              availableStatus: [],\r\n              availableLocales: [],\r\n            },\r\n          };\r\n        }\r\n\r\n        return response;\r\n      },\r\n    }),\r\n    deleteDocument: builder.mutation<\r\n      Delete.Response,\r\n      Pick<Delete.Params, 'model'> &\r\n        Pick<Partial<Delete.Params>, 'documentId'> & {\r\n          collectionType: string;\r\n          params?: Find.Request['query'];\r\n        }\r\n    >({\r\n      query: ({ collectionType, model, documentId, params }) => ({\r\n        url: `/content-manager/${collectionType}/${model}${\r\n          collectionType !== SINGLE_TYPES && documentId ? `/${documentId}` : ''\r\n        }`,\r\n        method: 'DELETE',\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_result, _error, { collectionType, model }) => [\r\n        { type: 'Document', id: collectionType !== SINGLE_TYPES ? `${model}_LIST` : model },\r\n        'RecentDocumentList',\r\n        'CountDocuments',\r\n      ],\r\n    }),\r\n    deleteManyDocuments: builder.mutation<\r\n      BulkDelete.Response,\r\n      BulkDelete.Params & BulkDelete.Request['body'] & { params?: Find.Request['query'] }\r\n    >({\r\n      query: ({ model, params, ...body }) => ({\r\n        url: `/content-manager/collection-types/${model}/actions/bulkDelete`,\r\n        method: 'POST',\r\n        data: body,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_res, _error, { model }) => [\r\n        { type: 'Document', id: `${model}_LIST` },\r\n        'RecentDocumentList',\r\n        'CountDocuments',\r\n      ],\r\n    }),\r\n    discardDocument: builder.mutation<\r\n      Discard.Response,\r\n      Pick<Discard.Params, 'model'> &\r\n        Partial<Pick<Discard.Params, 'documentId'>> & {\r\n          collectionType: string;\r\n          params?: Find.Request['query'] & {\r\n            [key: string]: any;\r\n          };\r\n        }\r\n    >({\r\n      query: ({ collectionType, model, documentId, params }) => ({\r\n        url: documentId\r\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/discard`\r\n          : `/content-manager/${collectionType}/${model}/actions/discard`,\r\n        method: 'POST',\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\r\n        return [\r\n          {\r\n            type: 'Document',\r\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\r\n          },\r\n          { type: 'Document', id: `${model}_LIST` },\r\n          'Relations',\r\n          { type: 'UidAvailability', id: model },\r\n          'RecentDocumentList',\r\n          'CountDocuments',\r\n        ];\r\n      },\r\n    }),\r\n    /**\r\n     * Gets all documents of a collection type or single type.\r\n     * By passing different params you can get different results e.g. only published documents or 'es' documents.\r\n     */\r\n    getAllDocuments: builder.query<\r\n      Find.Response,\r\n      Find.Params & {\r\n        params?: Find.Request['query'] & {\r\n          [key: string]: any;\r\n        };\r\n      }\r\n    >({\r\n      query: ({ model, params }) => ({\r\n        url: `/content-manager/collection-types/${model}`,\r\n        method: 'GET',\r\n        config: {\r\n          params: stringify(params, { encode: true }),\r\n        },\r\n      }),\r\n      providesTags: (result, _error, arg) => {\r\n        return [\r\n          { type: 'Document', id: `ALL_LIST` },\r\n          { type: 'Document', id: `${arg.model}_LIST` },\r\n          ...(result?.results.map(({ documentId }) => ({\r\n            type: 'Document' as const,\r\n            id: `${arg.model}_${documentId}`,\r\n          })) ?? []),\r\n        ];\r\n      },\r\n    }),\r\n    getDraftRelationCount: builder.query<\r\n      CountDraftRelations.Response,\r\n      {\r\n        collectionType: string;\r\n        model: string;\r\n        /**\r\n         * You don't pass the documentId if the document is a single-type\r\n         */\r\n        documentId?: string;\r\n        params?: CountDraftRelations.Request['query'];\r\n      }\r\n    >({\r\n      query: ({ collectionType, model, documentId, params }) => ({\r\n        url: documentId\r\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/countDraftRelations`\r\n          : `/content-manager/${collectionType}/${model}/actions/countDraftRelations`,\r\n        method: 'GET',\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n    }),\r\n    getDocument: builder.query<\r\n      FindOne.Response,\r\n      Pick<FindOne.Params, 'model'> &\r\n        Partial<Pick<FindOne.Params, 'documentId'>> & {\r\n          collectionType: string;\r\n          params?: FindOne.Request['query'];\r\n        }\r\n    >({\r\n      // @ts-expect-error â€“ TODO: fix ts error where data unknown doesn't work with response via an assertion?\r\n      queryFn: async (\r\n        { collectionType, model, documentId, params },\r\n        _api,\r\n        _extraOpts,\r\n        baseQuery\r\n      ) => {\r\n        const res = await baseQuery({\r\n          url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,\r\n          method: 'GET',\r\n          config: {\r\n            params,\r\n          },\r\n        });\r\n\r\n        /**\r\n         * To stop the query from locking itself in multiple retries, we intercept the error here and manage correctly.\r\n         * This is because single-types don't have a list view and fetching them with the route `/single-types/:model`\r\n         * never returns a list, just a single document but this won't exist if you've not made one before.\r\n         */\r\n        if (res.error && res.error.name === 'NotFoundError' && collectionType === SINGLE_TYPES) {\r\n          return { data: { document: undefined }, error: undefined };\r\n        }\r\n\r\n        return res;\r\n      },\r\n      providesTags: (result, _error, { collectionType, model, documentId }) => {\r\n        return [\r\n          // we prefer the result's id because we don't fetch single-types with an ID.\r\n          {\r\n            type: 'Document',\r\n            id:\r\n              collectionType !== SINGLE_TYPES\r\n                ? `${model}_${result && 'documentId' in result ? result.documentId : documentId}`\r\n                : model,\r\n          },\r\n          // Make it easy to invalidate all individual documents queries for a model\r\n          {\r\n            type: 'Document',\r\n            id: `${model}_ALL_ITEMS`,\r\n          },\r\n        ];\r\n      },\r\n    }),\r\n    getManyDraftRelationCount: builder.query<\r\n      CountManyEntriesDraftRelations.Response['data'],\r\n      CountManyEntriesDraftRelations.Request['query'] & {\r\n        model: string;\r\n      }\r\n    >({\r\n      query: ({ model, ...params }) => ({\r\n        url: `/content-manager/collection-types/${model}/actions/countManyEntriesDraftRelations`,\r\n        method: 'GET',\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      transformResponse: (response: CountManyEntriesDraftRelations.Response) => response.data,\r\n    }),\r\n    /**\r\n     * This endpoint will either create or update documents at the same time as publishing.\r\n     */\r\n    publishDocument: builder.mutation<\r\n      Publish.Response,\r\n      Pick<Publish.Params, 'model'> &\r\n        Partial<Pick<Publish.Params, 'documentId'>> & {\r\n          collectionType: string;\r\n          data: Publish.Request['body'];\r\n          params?: Publish.Request['query'];\r\n        }\r\n    >({\r\n      query: ({ collectionType, model, documentId, params, data }) => ({\r\n        url: documentId\r\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/publish`\r\n          : `/content-manager/${collectionType}/${model}/actions/publish`,\r\n        method: 'POST',\r\n        data,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\r\n        return [\r\n          {\r\n            type: 'Document',\r\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\r\n          },\r\n          { type: 'Document', id: `${model}_LIST` },\r\n          'Relations',\r\n          'RecentDocumentList',\r\n          'GuidedTourMeta',\r\n          'CountDocuments',\r\n        ];\r\n      },\r\n    }),\r\n    publishManyDocuments: builder.mutation<\r\n      BulkPublish.Response,\r\n      BulkPublish.Params & BulkPublish.Request['body'] & { params?: BulkPublish.Request['query'] }\r\n    >({\r\n      query: ({ model, params, ...body }) => ({\r\n        url: `/content-manager/collection-types/${model}/actions/bulkPublish`,\r\n        method: 'POST',\r\n        data: body,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_res, _error, { model, documentIds }) => {\r\n        return [\r\n          ...documentIds.map((id) => ({ type: 'Document' as const, id: `${model}_${id}` })),\r\n          'RecentDocumentList',\r\n          'CountDocuments',\r\n        ];\r\n      },\r\n    }),\r\n    updateDocument: builder.mutation<\r\n      Update.Response,\r\n      Pick<Update.Params, 'model'> &\r\n        Partial<Pick<Update.Params, 'documentId'>> & {\r\n          collectionType: string;\r\n          data: Update.Request['body'];\r\n          params?: Update.Request['query'];\r\n        }\r\n    >({\r\n      query: ({ collectionType, model, documentId, data, params }) => ({\r\n        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,\r\n        method: 'PUT',\r\n        data,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\r\n        return [\r\n          {\r\n            type: 'Document',\r\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\r\n          },\r\n          'Relations',\r\n          { type: 'UidAvailability', id: model },\r\n          'RecentDocumentList',\r\n          'CountDocuments',\r\n        ];\r\n      },\r\n      async onQueryStarted({ data, ...patch }, { dispatch, queryFulfilled }) {\r\n        // Optimistically update the cache with the new data\r\n        const patchResult = dispatch(\r\n          documentApi.util.updateQueryData('getDocument', patch, (draft) => {\r\n            Object.assign(draft.data, data);\r\n          })\r\n        );\r\n        try {\r\n          await queryFulfilled;\r\n        } catch {\r\n          // Rollback the optimistic update if there's an error\r\n          patchResult.undo();\r\n        }\r\n      },\r\n      transformResponse: (response: Update.Response, meta, arg): Update.Response => {\r\n        /**\r\n         * TODO v6\r\n         * Adapt plugin:users-permissions.user to return the same response\r\n         * shape as all other requests. The error is returned as expected.\r\n         */\r\n        if (!('data' in response) && arg.model === 'plugin::users-permissions.user') {\r\n          return {\r\n            data: response,\r\n            meta: {\r\n              availableStatus: [],\r\n              availableLocales: [],\r\n            },\r\n          };\r\n        }\r\n\r\n        return response;\r\n      },\r\n    }),\r\n    unpublishDocument: builder.mutation<\r\n      Unpublish.Response,\r\n      Pick<Unpublish.Params, 'model'> &\r\n        Partial<Pick<Unpublish.Params, 'documentId'>> & {\r\n          collectionType: string;\r\n          params?: Unpublish.Request['query'];\r\n          data: Unpublish.Request['body'];\r\n        }\r\n    >({\r\n      query: ({ collectionType, model, documentId, params, data }) => ({\r\n        url: documentId\r\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/unpublish`\r\n          : `/content-manager/${collectionType}/${model}/actions/unpublish`,\r\n        method: 'POST',\r\n        data,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\r\n        return [\r\n          {\r\n            type: 'Document',\r\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\r\n          },\r\n          'RecentDocumentList',\r\n          'CountDocuments',\r\n        ];\r\n      },\r\n    }),\r\n    unpublishManyDocuments: builder.mutation<\r\n      BulkUnpublish.Response,\r\n      Pick<BulkUnpublish.Params, 'model'> &\r\n        BulkUnpublish.Request['body'] & {\r\n          params?: BulkUnpublish.Request['query'];\r\n        }\r\n    >({\r\n      query: ({ model, params, ...body }) => ({\r\n        url: `/content-manager/collection-types/${model}/actions/bulkUnpublish`,\r\n        method: 'POST',\r\n        data: body,\r\n        config: {\r\n          params,\r\n        },\r\n      }),\r\n      invalidatesTags: (_res, _error, { model, documentIds }) => [\r\n        ...documentIds.map((id) => ({ type: 'Document' as const, id: `${model}_${id}` })),\r\n        'RecentDocumentList',\r\n        'CountDocuments',\r\n      ],\r\n    }),\r\n  }),\r\n});\r\n\r\nconst {\r\n  useAutoCloneDocumentMutation,\r\n  useCloneDocumentMutation,\r\n  useCreateDocumentMutation,\r\n  useDeleteDocumentMutation,\r\n  useDeleteManyDocumentsMutation,\r\n  useDiscardDocumentMutation,\r\n  useGetAllDocumentsQuery,\r\n  useLazyGetDocumentQuery,\r\n  useGetDocumentQuery,\r\n  useLazyGetDraftRelationCountQuery,\r\n  useGetManyDraftRelationCountQuery,\r\n  usePublishDocumentMutation,\r\n  usePublishManyDocumentsMutation,\r\n  useUpdateDocumentMutation,\r\n  useUnpublishDocumentMutation,\r\n  useUnpublishManyDocumentsMutation,\r\n} = documentApi;\r\n\r\nexport {\r\n  useAutoCloneDocumentMutation,\r\n  useCloneDocumentMutation,\r\n  useCreateDocumentMutation,\r\n  useDeleteDocumentMutation,\r\n  useDeleteManyDocumentsMutation,\r\n  useDiscardDocumentMutation,\r\n  useGetAllDocumentsQuery,\r\n  useLazyGetDocumentQuery,\r\n  useGetDocumentQuery,\r\n  useLazyGetDraftRelationCountQuery as useGetDraftRelationCountQuery,\r\n  useGetManyDraftRelationCountQuery,\r\n  usePublishDocumentMutation,\r\n  usePublishManyDocumentsMutation,\r\n  useUpdateDocumentMutation,\r\n  useUnpublishDocumentMutation,\r\n  useUnpublishManyDocumentsMutation,\r\n};\r\n", "import { SerializedError } from '@reduxjs/toolkit';\r\nimport { ApiError, type UnknownApiError } from '@strapi/admin/strapi-admin';\r\n\r\ninterface Query {\r\n  plugins?: Record<string, unknown>;\r\n  _q?: string;\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * This type extracts the plugin options from the query\r\n * and appends them to the root of the query\r\n */\r\ntype TransformedQuery<TQuery extends Query> = Omit<TQuery, 'plugins'> & {\r\n  [key: string]: string;\r\n};\r\n\r\n/**\r\n * @description\r\n * Creates a valid query params object for get requests\r\n * ie. plugins[18n][locale]=en becomes locale=en\r\n */\r\nconst buildValidParams = <TQuery extends Query>(query: TQuery): TransformedQuery<TQuery> => {\r\n  if (!query) return query;\r\n\r\n  // Extract pluginOptions from the query, they shouldn't be part of the URL\r\n  const { plugins: _, ...validQueryParams } = {\r\n    ...query,\r\n    ...Object.values(query?.plugins ?? {}).reduce<Record<string, string>>(\r\n      (acc, current) => Object.assign(acc, current),\r\n      {}\r\n    ),\r\n  };\r\n\r\n  return validQueryParams;\r\n};\r\n\r\ntype BaseQueryError = ApiError | UnknownApiError;\r\n\r\nconst isBaseQueryError = (error: BaseQueryError | SerializedError): error is BaseQueryError => {\r\n  return error.name !== undefined;\r\n};\r\n\r\nexport { isBaseQueryError, buildValidParams };\r\nexport type { BaseQueryError, UnknownApiError };\r\n", "import { translatedErrors } from '@strapi/admin/strapi-admin';\r\nimport pipe from 'lodash/fp/pipe';\r\nimport * as yup from 'yup';\r\n\r\nimport { DOCUMENT_META_FIELDS } from '../constants/attributes';\r\n\r\nimport type { ComponentsDictionary, Schema } from '../hooks/useDocument';\r\nimport type { Schema as SchemaUtils } from '@strapi/types';\r\nimport type { ObjectShape } from 'yup/lib/object';\r\n\r\ntype AnySchema =\r\n  | yup.StringSchema\r\n  | yup.NumberSchema\r\n  | yup.BooleanSchema\r\n  | yup.DateSchema\r\n  | yup.ArraySchema<any>\r\n  | yup.ObjectSchema<any>;\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * createYupSchema\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\ninterface ValidationOptions {\r\n  status: 'draft' | 'published' | null;\r\n  removedAttributes?: string[];\r\n}\r\n\r\nconst arrayValidator = (attribute: Schema['attributes'][string], options: ValidationOptions) => ({\r\n  message: translatedErrors.required,\r\n  test(value: unknown) {\r\n    if (options.status === 'draft') {\r\n      return true;\r\n    }\r\n\r\n    if (!attribute.required) {\r\n      return true;\r\n    }\r\n\r\n    if (!value) {\r\n      return false;\r\n    }\r\n\r\n    if (Array.isArray(value) && value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  },\r\n});\r\nconst escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n/**\r\n * TODO: should we create a Map to store these based on the hash of the schema?\r\n */\r\nconst createYupSchema = (\r\n  attributes: Schema['attributes'] = {},\r\n  components: ComponentsDictionary = {},\r\n  options: ValidationOptions = { status: null }\r\n): yup.ObjectSchema<any> => {\r\n  const createModelSchema = (\r\n    attributes: Schema['attributes'],\r\n    removedAttributes: string[] = []\r\n  ): yup.ObjectSchema<any> =>\r\n    yup\r\n      .object()\r\n      .shape(\r\n        Object.entries(attributes).reduce<ObjectShape>((acc, [name, attribute]) => {\r\n          const getNestedPathsForAttribute = (removed: string[], attrName: string): string[] => {\r\n            const prefix = `${attrName}.`;\r\n            const bracketRegex = new RegExp(`^${escapeRegex(attrName)}\\\\[\\\\d+\\\\]\\\\.`);\r\n\r\n            return removed\r\n              .filter((p) => p.startsWith(prefix) || bracketRegex.test(p))\r\n              .map((p) =>\r\n                p.startsWith(prefix) ? p.slice(prefix.length) : p.replace(bracketRegex, '')\r\n              );\r\n          };\r\n\r\n          if (DOCUMENT_META_FIELDS.includes(name)) {\r\n            return acc;\r\n          }\r\n\r\n          if (removedAttributes?.includes(name)) {\r\n            // If the attribute is not visible, we don't want to validate it\r\n            return acc;\r\n          }\r\n\r\n          const nestedRemoved = getNestedPathsForAttribute(removedAttributes, name);\r\n\r\n          /**\r\n           * These validations won't apply to every attribute\r\n           * and that's okay, in that case we just return the\r\n           * schema as it was passed.\r\n           */\r\n          const validations = [\r\n            addNullableValidation,\r\n            addRequiredValidation,\r\n            addMinLengthValidation,\r\n            addMaxLengthValidation,\r\n            addMinValidation,\r\n            addMaxValidation,\r\n            addRegexValidation,\r\n          ].map((fn) => fn(attribute, options));\r\n\r\n          const transformSchema = pipe(...validations);\r\n\r\n          switch (attribute.type) {\r\n            case 'component': {\r\n              const { attributes } = components[attribute.component];\r\n\r\n              if (attribute.repeatable) {\r\n                return {\r\n                  ...acc,\r\n                  [name]: transformSchema(\r\n                    yup.array().of(createModelSchema(attributes, nestedRemoved).nullable(false))\r\n                  ).test(arrayValidator(attribute, options)),\r\n                };\r\n              } else {\r\n                return {\r\n                  ...acc,\r\n                  [name]: transformSchema(createModelSchema(attributes, nestedRemoved).nullable()),\r\n                };\r\n              }\r\n            }\r\n            case 'dynamiczone':\r\n              return {\r\n                ...acc,\r\n                [name]: transformSchema(\r\n                  yup.array().of(\r\n                    yup.lazy(\r\n                      (\r\n                        data: SchemaUtils.Attribute.Value<SchemaUtils.Attribute.DynamicZone>[number]\r\n                      ) => {\r\n                        const attributes = components?.[data?.__component]?.attributes;\r\n\r\n                        const validation = yup\r\n                          .object()\r\n                          .shape({\r\n                            __component: yup.string().required().oneOf(Object.keys(components)),\r\n                          })\r\n                          .nullable(false);\r\n                        if (!attributes) {\r\n                          return validation;\r\n                        }\r\n\r\n                        return validation.concat(createModelSchema(attributes, nestedRemoved));\r\n                      }\r\n                    ) as unknown as yup.ObjectSchema<any>\r\n                  )\r\n                ).test(arrayValidator(attribute, options)),\r\n              };\r\n            case 'relation':\r\n              return {\r\n                ...acc,\r\n                [name]: transformSchema(\r\n                  yup.lazy((value) => {\r\n                    if (!value) {\r\n                      return yup.mixed().nullable(true);\r\n                    } else if (Array.isArray(value)) {\r\n                      // If a relation value is an array, we expect\r\n                      // an array of objects with {id} properties, representing the related entities.\r\n                      return yup.array().of(\r\n                        yup.object().shape({\r\n                          id: yup.number().required(),\r\n                        })\r\n                      );\r\n                    } else if (typeof value === 'object') {\r\n                      // A realtion value can also be an object. Some API\r\n                      // repsonses return the number of entities in the relation\r\n                      // as { count: x }\r\n                      return yup.object();\r\n                    } else {\r\n                      return yup\r\n                        .mixed()\r\n                        .test(\r\n                          'type-error',\r\n                          'Relation values must be either null, an array of objects with {id} or an object.',\r\n                          () => false\r\n                        );\r\n                    }\r\n                  })\r\n                ),\r\n              };\r\n            default:\r\n              return {\r\n                ...acc,\r\n                [name]: transformSchema(createAttributeSchema(attribute)),\r\n              };\r\n          }\r\n        }, {})\r\n      )\r\n      /**\r\n       * TODO: investigate why an undefined object fails a check of `nullable`.\r\n       */\r\n      .default(null);\r\n\r\n  return createModelSchema(attributes, options.removedAttributes);\r\n};\r\n\r\nconst createAttributeSchema = (\r\n  attribute: Exclude<\r\n    SchemaUtils.Attribute.AnyAttribute,\r\n    { type: 'dynamiczone' } | { type: 'component' } | { type: 'relation' }\r\n  >\r\n) => {\r\n  switch (attribute.type) {\r\n    case 'biginteger':\r\n      return yup.string().matches(/^-?\\d*$/);\r\n    case 'boolean':\r\n      return yup.boolean();\r\n    case 'blocks':\r\n      return yup.mixed().test('isBlocks', translatedErrors.json, (value) => {\r\n        if (!value || Array.isArray(value)) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      });\r\n    case 'decimal':\r\n    case 'float':\r\n    case 'integer':\r\n      return yup.number();\r\n    case 'email':\r\n      return yup.string().email(translatedErrors.email);\r\n    case 'enumeration':\r\n      return yup.string().oneOf([...attribute.enum, null]);\r\n    case 'json':\r\n      return yup.mixed().test('isJSON', translatedErrors.json, (value) => {\r\n        /**\r\n         * We don't want to validate the JSON field if it's empty.\r\n         */\r\n        if (!value || (typeof value === 'string' && value.length === 0)) {\r\n          return true;\r\n        }\r\n\r\n        // If the value was created via content API and wasn't changed, then it's still an object\r\n        if (typeof value === 'object') {\r\n          try {\r\n            JSON.stringify(value);\r\n            return true;\r\n          } catch (err) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        try {\r\n          JSON.parse(value);\r\n\r\n          return true;\r\n        } catch (err) {\r\n          return false;\r\n        }\r\n      });\r\n    case 'password':\r\n    case 'richtext':\r\n    case 'string':\r\n    case 'text':\r\n      return yup.string();\r\n    case 'uid':\r\n      return yup\r\n        .string()\r\n        .matches(attribute.regex ? new RegExp(attribute.regex) : /^[A-Za-z0-9-_.~]*$/);\r\n    default:\r\n      /**\r\n       * This allows any value.\r\n       */\r\n      return yup.mixed();\r\n  }\r\n};\r\n\r\n// Helper function to return schema.nullable() if it exists, otherwise return schema\r\nconst nullableSchema = <TSchema extends AnySchema>(schema: TSchema) => {\r\n  return schema?.nullable\r\n    ? schema.nullable()\r\n    : // In some cases '.nullable' will not be available on the schema.\r\n      // e.g. when the schema has been built using yup.lazy (e.g. for relations).\r\n      // In these cases we should just return the schema as it is.\r\n      schema;\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Validators\r\n * -----------------------------------------------------------------------------------------------*/\r\n/**\r\n * Our validator functions can be preped with the\r\n * attribute and then have the schema piped through them.\r\n */\r\ntype ValidationFn = (\r\n  attribute: Schema['attributes'][string],\r\n  options: ValidationOptions\r\n) => <TSchema extends AnySchema>(schema: TSchema) => TSchema;\r\n\r\nconst addNullableValidation: ValidationFn = () => (schema) => {\r\n  return nullableSchema(schema);\r\n};\r\n\r\nconst addRequiredValidation: ValidationFn = (attribute, options) => (schema) => {\r\n  if (options.status === 'draft' || !attribute.required) {\r\n    return schema;\r\n  }\r\n\r\n  if (attribute.required && 'required' in schema) {\r\n    return schema.required(translatedErrors.required);\r\n  }\r\n\r\n  return schema;\r\n};\r\n\r\nconst addMinLengthValidation: ValidationFn =\r\n  (attribute, options) =>\r\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\r\n    // Skip minLength validation for draft\r\n    if (options.status === 'draft') {\r\n      return schema;\r\n    }\r\n\r\n    if (\r\n      'minLength' in attribute &&\r\n      attribute.minLength &&\r\n      Number.isInteger(attribute.minLength) &&\r\n      'min' in schema\r\n    ) {\r\n      return schema.min(attribute.minLength, {\r\n        ...translatedErrors.minLength,\r\n        values: {\r\n          min: attribute.minLength,\r\n        },\r\n      }) as TSchema;\r\n    }\r\n\r\n    return schema;\r\n  };\r\n\r\nconst addMaxLengthValidation: ValidationFn =\r\n  (attribute) =>\r\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\r\n    if (\r\n      'maxLength' in attribute &&\r\n      attribute.maxLength &&\r\n      Number.isInteger(attribute.maxLength) &&\r\n      'max' in schema\r\n    ) {\r\n      return schema.max(attribute.maxLength, {\r\n        ...translatedErrors.maxLength,\r\n        values: {\r\n          max: attribute.maxLength,\r\n        },\r\n      }) as TSchema;\r\n    }\r\n\r\n    return schema;\r\n  };\r\n\r\nconst addMinValidation: ValidationFn =\r\n  (attribute, options) =>\r\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\r\n    // do not validate min for draft\r\n    if (options.status === 'draft') {\r\n      return schema;\r\n    }\r\n\r\n    if ('min' in attribute && 'min' in schema) {\r\n      const min = toInteger(attribute.min);\r\n\r\n      if (min) {\r\n        return schema.min(min, {\r\n          ...translatedErrors.min,\r\n          values: {\r\n            min,\r\n          },\r\n        }) as TSchema;\r\n      }\r\n    }\r\n\r\n    return schema;\r\n  };\r\n\r\nconst addMaxValidation: ValidationFn =\r\n  (attribute) =>\r\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\r\n    if ('max' in attribute) {\r\n      const max = toInteger(attribute.max);\r\n\r\n      if ('max' in schema && max) {\r\n        return schema.max(max, {\r\n          ...translatedErrors.max,\r\n          values: {\r\n            max,\r\n          },\r\n        }) as TSchema;\r\n      }\r\n    }\r\n\r\n    return schema;\r\n  };\r\n\r\nconst toInteger = (val?: string | number): number | undefined => {\r\n  if (typeof val === 'number' || val === undefined) {\r\n    return val;\r\n  } else {\r\n    const num = Number(val);\r\n    return isNaN(num) ? undefined : num;\r\n  }\r\n};\r\n\r\nconst addRegexValidation: ValidationFn =\r\n  (attribute) =>\r\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\r\n    if ('regex' in attribute && attribute.regex && 'matches' in schema) {\r\n      return schema.matches(new RegExp(attribute.regex), {\r\n        message: {\r\n          id: translatedErrors.regex.id,\r\n          defaultMessage: 'The value does not match the defined pattern.',\r\n        },\r\n\r\n        excludeEmptyString: !attribute.required,\r\n      }) as TSchema;\r\n    }\r\n\r\n    return schema;\r\n  };\r\n\r\nexport { createYupSchema };\r\n", "import { contentManagerApi } from './api';\r\n\r\nimport type { GetInitData } from '../../../shared/contracts/init';\r\n\r\nconst initApi = contentManagerApi.injectEndpoints({\r\n  endpoints: (builder) => ({\r\n    getInitialData: builder.query<GetInitData.Response['data'], void>({\r\n      query: () => '/content-manager/init',\r\n      transformResponse: (response: GetInitData.Response) => response.data,\r\n      providesTags: ['InitialData'],\r\n    }),\r\n  }),\r\n});\r\n\r\nconst { useGetInitialDataQuery } = initApi;\r\n\r\nexport { useGetInitialDataQuery };\r\n", "import * as React from 'react';\r\n\r\nimport { useNotification, useAPIErrorHandler } from '@strapi/admin/strapi-admin';\r\n\r\nimport { useGetInitialDataQuery } from '../services/init';\r\n\r\nimport type { Component } from '../../../shared/contracts/components';\r\nimport type { ContentType } from '../../../shared/contracts/content-types';\r\nimport type { Schema } from '@strapi/types';\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * useContentTypeSchema\r\n * -----------------------------------------------------------------------------------------------*/\r\ntype ComponentsDictionary = Record<string, Component>;\r\n\r\n/**\r\n * @internal\r\n * @description Given a model UID, return the schema and the schemas\r\n * of the associated components within said model's schema. A wrapper\r\n * implementation around the `useGetInitialDataQuery` with a unique\r\n * `selectFromResult` function to memoize the calculation.\r\n *\r\n * If no model is provided, the hook will return all the schemas.\r\n */\r\nconst useContentTypeSchema = (model?: string) => {\r\n  const { toggleNotification } = useNotification();\r\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\r\n\r\n  const { data, error, isLoading, isFetching } = useGetInitialDataQuery(undefined);\r\n\r\n  const { components, contentType, contentTypes } = React.useMemo(() => {\r\n    const contentType = data?.contentTypes.find((ct) => ct.uid === model);\r\n\r\n    const componentsByKey = data?.components.reduce<ComponentsDictionary>((acc, component) => {\r\n      acc[component.uid] = component;\r\n\r\n      return acc;\r\n    }, {});\r\n\r\n    const components = extractContentTypeComponents(contentType?.attributes, componentsByKey);\r\n\r\n    return {\r\n      components: Object.keys(components).length === 0 ? undefined : components,\r\n      contentType,\r\n      contentTypes: data?.contentTypes ?? [],\r\n    };\r\n  }, [model, data]);\r\n\r\n  React.useEffect(() => {\r\n    if (error) {\r\n      toggleNotification({\r\n        type: 'danger',\r\n        message: formatAPIError(error),\r\n      });\r\n    }\r\n  }, [toggleNotification, error, formatAPIError]);\r\n\r\n  return {\r\n    // This must be memoized to avoid inifiinite re-renders where the empty object is different everytime.\r\n    components: React.useMemo(() => components ?? {}, [components]),\r\n    schema: contentType,\r\n    schemas: contentTypes,\r\n    isLoading: isLoading || isFetching,\r\n  };\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * extractContentTypeComponents\r\n * -----------------------------------------------------------------------------------------------*/\r\n/**\r\n * @internal\r\n * @description Extracts the components used in a content type's attributes recursively.\r\n */\r\nconst extractContentTypeComponents = (\r\n  attributes: ContentType['attributes'] = {},\r\n  allComponents: ComponentsDictionary = {}\r\n): ComponentsDictionary => {\r\n  const getComponents = (attributes: Schema.Attribute.AnyAttribute[]) => {\r\n    return attributes.reduce<string[]>((acc, attribute) => {\r\n      /**\r\n       * If the attribute is a component or dynamiczone, we need to recursively\r\n       * extract the component UIDs from its attributes.\r\n       */\r\n      if (attribute.type === 'component') {\r\n        const componentAttributes = Object.values(\r\n          allComponents[attribute.component]?.attributes ?? {}\r\n        );\r\n\r\n        acc.push(attribute.component, ...getComponents(componentAttributes));\r\n      } else if (attribute.type === 'dynamiczone') {\r\n        acc.push(\r\n          ...attribute.components,\r\n          /**\r\n           * Dynamic zones have an array of components, so we flatMap over them\r\n           * performing the same search as above.\r\n           */\r\n          ...attribute.components.flatMap((componentUid) => {\r\n            const componentAttributes = Object.values(\r\n              allComponents[componentUid]?.attributes ?? {}\r\n            );\r\n\r\n            return getComponents(componentAttributes);\r\n          })\r\n        );\r\n      }\r\n\r\n      return acc;\r\n    }, []);\r\n  };\r\n\r\n  const componentUids = getComponents(Object.values(attributes));\r\n\r\n  const uniqueComponentUids = [...new Set(componentUids)];\r\n\r\n  const componentsByKey = uniqueComponentUids.reduce<ComponentsDictionary>((acc, uid) => {\r\n    acc[uid] = allComponents[uid];\r\n\r\n    return acc;\r\n  }, {});\r\n\r\n  return componentsByKey;\r\n};\r\n\r\nexport { useContentTypeSchema, extractContentTypeComponents };\r\nexport type { ComponentsDictionary };\r\n", "export const HOOKS = {\r\n  /**\r\n   * Hook that allows to mutate the displayed headers of the list view table\r\n   * @constant\r\n   * @type {string}\r\n   */\r\n  INJECT_COLUMN_IN_TABLE: 'Admin/CM/pages/ListView/inject-column-in-table',\r\n\r\n  /**\r\n   * Hook that allows to mutate the CM's collection types links pre-set filters\r\n   * @constant\r\n   * @type {string}\r\n   */\r\n  MUTATE_COLLECTION_TYPES_LINKS: 'Admin/CM/pages/App/mutate-collection-types-links',\r\n\r\n  /**\r\n   * Hook that allows to mutate the CM's edit view layout\r\n   * @constant\r\n   * @type {string}\r\n   */\r\n  MUTATE_EDIT_VIEW_LAYOUT: 'Admin/CM/pages/EditView/mutate-edit-view-layout',\r\n\r\n  /**\r\n   * Hook that allows to mutate the CM's single types links pre-set filters\r\n   * @constant\r\n   * @type {string}\r\n   */\r\n  MUTATE_SINGLE_TYPES_LINKS: 'Admin/CM/pages/App/mutate-single-types-links',\r\n};\r\n", "import {\r\n  FindContentTypeConfiguration,\r\n  UpdateContentTypeConfiguration,\r\n  FindContentTypesSettings,\r\n} from '../../../shared/contracts/content-types';\r\n\r\nimport { contentManagerApi } from './api';\r\n\r\nconst contentTypesApi = contentManagerApi.injectEndpoints({\r\n  endpoints: (builder) => ({\r\n    getContentTypeConfiguration: builder.query<\r\n      FindContentTypeConfiguration.Response['data'],\r\n      string\r\n    >({\r\n      query: (uid) => ({\r\n        url: `/content-manager/content-types/${uid}/configuration`,\r\n        method: 'GET',\r\n      }),\r\n      transformResponse: (response: FindContentTypeConfiguration.Response) => response.data,\r\n      providesTags: (_result, _error, uid) => [\r\n        { type: 'ContentTypesConfiguration', id: uid },\r\n        { type: 'ContentTypeSettings', id: 'LIST' },\r\n      ],\r\n    }),\r\n    getAllContentTypeSettings: builder.query<FindContentTypesSettings.Response['data'], void>({\r\n      query: () => '/content-manager/content-types-settings',\r\n      transformResponse: (response: FindContentTypesSettings.Response) => response.data,\r\n      providesTags: [{ type: 'ContentTypeSettings', id: 'LIST' }],\r\n    }),\r\n    updateContentTypeConfiguration: builder.mutation<\r\n      UpdateContentTypeConfiguration.Response['data'],\r\n      UpdateContentTypeConfiguration.Request['body'] & {\r\n        uid: string;\r\n      }\r\n    >({\r\n      query: ({ uid, ...body }) => ({\r\n        url: `/content-manager/content-types/${uid}/configuration`,\r\n        method: 'PUT',\r\n        data: body,\r\n      }),\r\n      transformResponse: (response: UpdateContentTypeConfiguration.Response) => response.data,\r\n      invalidatesTags: (_result, _error, { uid }) => [\r\n        { type: 'ContentTypesConfiguration', id: uid },\r\n        { type: 'ContentTypeSettings', id: 'LIST' },\r\n        // Is this necessary?\r\n        { type: 'InitialData' },\r\n      ],\r\n    }),\r\n  }),\r\n});\r\n\r\nconst {\r\n  useGetContentTypeConfigurationQuery,\r\n  useGetAllContentTypeSettingsQuery,\r\n  useUpdateContentTypeConfigurationMutation,\r\n} = contentTypesApi;\r\n\r\nexport {\r\n  useGetContentTypeConfigurationQuery,\r\n  useGetAllContentTypeSettingsQuery,\r\n  useUpdateContentTypeConfigurationMutation,\r\n};\r\n", "import * as React from 'react';\r\n\r\nimport { SerializedError } from '@reduxjs/toolkit';\r\nimport {\r\n  useNotification,\r\n  useStrapiApp,\r\n  useAPIErrorHandler,\r\n  useQueryParams,\r\n} from '@strapi/admin/strapi-admin';\r\n\r\nimport { HOOKS } from '../constants/hooks';\r\nimport { useGetContentTypeConfigurationQuery } from '../services/contentTypes';\r\nimport { BaseQueryError } from '../utils/api';\r\nimport { getMainField } from '../utils/attributes';\r\n\r\nimport { useContentTypeSchema } from './useContentTypeSchema';\r\nimport {\r\n  type ComponentsDictionary,\r\n  type Document,\r\n  type Schema,\r\n  useDoc,\r\n  useDocument,\r\n} from './useDocument';\r\n\r\nimport type { ComponentConfiguration } from '../../../shared/contracts/components';\r\nimport type {\r\n  Metadatas,\r\n  FindContentTypeConfiguration,\r\n  Settings,\r\n} from '../../../shared/contracts/content-types';\r\nimport type { Filters, InputProps, Table } from '@strapi/admin/strapi-admin';\r\nimport type { Schema as SchemaUtils } from '@strapi/types';\r\n\r\ntype LayoutOptions = Schema['options'] & Schema['pluginOptions'] & object;\r\n\r\ninterface LayoutSettings extends Settings {\r\n  displayName?: string;\r\n  icon?: never;\r\n}\r\n\r\ninterface ListFieldLayout\r\n  extends Table.Header<Document, ListFieldLayout>,\r\n    Pick<Filters.Filter, 'mainField'> {\r\n  attribute: SchemaUtils.Attribute.AnyAttribute | { type: 'custom' };\r\n}\r\n\r\ninterface ListLayout {\r\n  layout: ListFieldLayout[];\r\n  components?: never;\r\n  metadatas: {\r\n    [K in keyof Metadatas]: Metadatas[K]['list'];\r\n  };\r\n  options: LayoutOptions;\r\n  settings: LayoutSettings;\r\n}\r\ninterface EditFieldSharedProps\r\n  extends Omit<InputProps, 'hint' | 'label' | 'type'>,\r\n    Pick<Filters.Filter, 'mainField'> {\r\n  hint?: string;\r\n  label: string;\r\n  size: number;\r\n  unique?: boolean;\r\n  visible?: boolean;\r\n}\r\n\r\n/**\r\n * Map over all the types in Attribute Types and use that to create a union of new types where the attribute type\r\n * is under the property attribute and the type is under the property type.\r\n */\r\ntype EditFieldLayout = {\r\n  [K in SchemaUtils.Attribute.Kind]: EditFieldSharedProps & {\r\n    attribute: Extract<SchemaUtils.Attribute.AnyAttribute, { type: K }>;\r\n    type: K;\r\n  };\r\n}[SchemaUtils.Attribute.Kind];\r\n\r\ninterface EditLayout {\r\n  layout: Array<Array<EditFieldLayout[]>>;\r\n  components: {\r\n    [uid: string]: {\r\n      layout: Array<EditFieldLayout[]>;\r\n      settings: ComponentConfiguration['settings'] & {\r\n        displayName?: string;\r\n        icon?: string;\r\n      };\r\n    };\r\n  };\r\n  metadatas: {\r\n    [K in keyof Metadatas]: Metadatas[K]['edit'];\r\n  };\r\n  options: LayoutOptions;\r\n  settings: LayoutSettings;\r\n}\r\n\r\ntype UseDocumentLayout = (model: string) => {\r\n  error?: BaseQueryError | SerializedError;\r\n  isLoading: boolean;\r\n  /**\r\n   * This is the layout for the edit view,\r\n   */\r\n  edit: EditLayout;\r\n  list: ListLayout;\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * useDocumentLayout\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\nconst DEFAULT_SETTINGS = {\r\n  bulkable: false,\r\n  filterable: false,\r\n  searchable: false,\r\n  pagination: false,\r\n  defaultSortBy: '',\r\n  defaultSortOrder: 'asc',\r\n  mainField: 'id',\r\n  pageSize: 10,\r\n};\r\n\r\n/**\r\n * @alpha\r\n * @description This hook is used to get the layouts for either the edit view or list view of a specific content-type\r\n * including the layouts for the components used in the content-type. It also runs the mutation hook waterfall so the data\r\n * is consistent wherever it is used. It's a light wrapper around the `useDocument` hook, but provides the `skip` option a document\r\n * is not fetched, however, it does fetch the schemas & components if they do not already exist in the cache.\r\n *\r\n * If the fetch fails, it will display a notification to the user.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { model } = useParams<{ model: string }>();\r\n * const { edit: { schema: layout } } = useDocumentLayout(model);\r\n *\r\n * return layout.map(panel => panel.map(row => row.map(field => <Field.Root {...field} />)))\r\n * ```\r\n *\r\n */\r\nconst useDocumentLayout: UseDocumentLayout = (model) => {\r\n  const { schema, components } = useDocument({ model, collectionType: '' }, { skip: true });\r\n  const [{ query }] = useQueryParams();\r\n  const runHookWaterfall = useStrapiApp('useDocumentLayout', (state) => state.runHookWaterfall);\r\n  const { toggleNotification } = useNotification();\r\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\r\n  const { isLoading: isLoadingSchemas, schemas } = useContentTypeSchema();\r\n\r\n  const {\r\n    data,\r\n    isLoading: isLoadingConfigs,\r\n    error,\r\n    isFetching: isFetchingConfigs,\r\n  } = useGetContentTypeConfigurationQuery(model);\r\n\r\n  const isLoading = isLoadingSchemas || isFetchingConfigs || isLoadingConfigs;\r\n\r\n  React.useEffect(() => {\r\n    if (error) {\r\n      toggleNotification({\r\n        type: 'danger',\r\n        message: formatAPIError(error),\r\n      });\r\n    }\r\n  }, [error, formatAPIError, toggleNotification]);\r\n\r\n  const editLayout = React.useMemo(\r\n    () =>\r\n      data && !isLoading\r\n        ? formatEditLayout(data, { schemas, schema, components })\r\n        : ({\r\n            layout: [],\r\n            components: {},\r\n            metadatas: {},\r\n            options: {},\r\n            settings: DEFAULT_SETTINGS,\r\n          } as EditLayout),\r\n    [data, isLoading, schemas, schema, components]\r\n  );\r\n\r\n  const listLayout = React.useMemo(() => {\r\n    return data && !isLoading\r\n      ? formatListLayout(data, { schemas, schema, components })\r\n      : ({\r\n          layout: [],\r\n          metadatas: {},\r\n          options: {},\r\n          settings: DEFAULT_SETTINGS,\r\n        } as ListLayout);\r\n  }, [data, isLoading, schemas, schema, components]);\r\n\r\n  const { layout: edit } = React.useMemo(\r\n    () =>\r\n      runHookWaterfall(HOOKS.MUTATE_EDIT_VIEW_LAYOUT, {\r\n        layout: editLayout,\r\n        query,\r\n      }),\r\n    [editLayout, query, runHookWaterfall]\r\n  );\r\n\r\n  return {\r\n    error,\r\n    isLoading,\r\n    edit,\r\n    list: listLayout,\r\n  } satisfies ReturnType<UseDocumentLayout>;\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * useDocLayout\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal this hook uses the internal useDoc hook, as such it shouldn't be used outside of the\r\n * content-manager because it won't work as intended.\r\n */\r\nconst useDocLayout = () => {\r\n  const { model } = useDoc();\r\n  return useDocumentLayout(model);\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * formatEditLayout\r\n * -----------------------------------------------------------------------------------------------*/\r\ntype LayoutData = FindContentTypeConfiguration.Response['data'];\r\n\r\n/**\r\n * @internal\r\n * @description takes the configuration data, the schema & the components used in the schema and formats the edit view\r\n * versions of the schema & components. This is then used to render the edit view of the content-type.\r\n */\r\nconst formatEditLayout = (\r\n  data: LayoutData,\r\n  {\r\n    schemas,\r\n    schema,\r\n    components,\r\n  }: { schemas: Schema[]; schema?: Schema; components: ComponentsDictionary }\r\n): EditLayout => {\r\n  let currentPanelIndex = 0;\r\n  /**\r\n   * The fields arranged by the panels, new panels are made for dynamic zones only.\r\n   */\r\n  const panelledEditAttributes = convertEditLayoutToFieldLayouts(\r\n    data.contentType.layouts.edit,\r\n    schema?.attributes,\r\n    data.contentType.metadatas,\r\n    { configurations: data.components, schemas: components },\r\n    schemas\r\n  ).reduce<Array<EditFieldLayout[][]>>((panels, row) => {\r\n    if (row.some((field) => field.type === 'dynamiczone')) {\r\n      panels.push([row]);\r\n      currentPanelIndex += 2;\r\n    } else {\r\n      if (!panels[currentPanelIndex]) {\r\n        panels.push([row]);\r\n      } else {\r\n        panels[currentPanelIndex].push(row);\r\n      }\r\n    }\r\n\r\n    return panels;\r\n  }, []);\r\n\r\n  const componentEditAttributes = Object.entries(data.components).reduce<EditLayout['components']>(\r\n    (acc, [uid, configuration]) => {\r\n      acc[uid] = {\r\n        layout: convertEditLayoutToFieldLayouts(\r\n          configuration.layouts.edit,\r\n          components[uid].attributes,\r\n          configuration.metadatas,\r\n          { configurations: data.components, schemas: components }\r\n        ),\r\n        settings: {\r\n          ...configuration.settings,\r\n          icon: components[uid].info.icon,\r\n          displayName: components[uid].info.displayName,\r\n        },\r\n      };\r\n      return acc;\r\n    },\r\n    {}\r\n  );\r\n\r\n  const editMetadatas = Object.entries(data.contentType.metadatas).reduce<EditLayout['metadatas']>(\r\n    (acc, [attribute, metadata]) => {\r\n      return {\r\n        ...acc,\r\n        [attribute]: metadata.edit,\r\n      };\r\n    },\r\n    {}\r\n  );\r\n\r\n  return {\r\n    layout: panelledEditAttributes,\r\n    components: componentEditAttributes,\r\n    metadatas: editMetadatas,\r\n    settings: {\r\n      ...data.contentType.settings,\r\n      displayName: schema?.info.displayName,\r\n    },\r\n    options: {\r\n      ...schema?.options,\r\n      ...schema?.pluginOptions,\r\n      ...data.contentType.options,\r\n    },\r\n  };\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * convertEditLayoutToFieldLayouts\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal\r\n * @description takes the edit layout from either a content-type or a component\r\n * and formats it into a generic object that can be used to correctly render\r\n * the form fields.\r\n */\r\nconst convertEditLayoutToFieldLayouts = (\r\n  rows: LayoutData['contentType']['layouts']['edit'],\r\n  attributes: Schema['attributes'] = {},\r\n  metadatas: Metadatas,\r\n  components?: {\r\n    configurations: Record<string, ComponentConfiguration>;\r\n    schemas: ComponentsDictionary;\r\n  },\r\n  schemas: Schema[] = []\r\n) => {\r\n  return rows.map((row) =>\r\n    row\r\n      .map((field) => {\r\n        const attribute = attributes[field.name];\r\n\r\n        if (!attribute) {\r\n          return null;\r\n        }\r\n\r\n        const { edit: metadata } = metadatas[field.name];\r\n\r\n        const settings: Partial<Settings> =\r\n          attribute.type === 'component' && components\r\n            ? components.configurations[attribute.component].settings\r\n            : {};\r\n\r\n        return {\r\n          attribute,\r\n          disabled: !metadata.editable,\r\n          hint: metadata.description,\r\n          label: metadata.label ?? '',\r\n          name: field.name,\r\n          // @ts-expect-error â€“ mainField does exist on the metadata for a relation.\r\n          mainField: getMainField(attribute, metadata.mainField || settings.mainField, {\r\n            schemas,\r\n            components: components?.schemas ?? {},\r\n          }),\r\n          placeholder: metadata.placeholder ?? '',\r\n          required: attribute.required ?? false,\r\n          size: field.size,\r\n          unique: 'unique' in attribute ? attribute.unique : false,\r\n          visible: metadata.visible ?? true,\r\n          type: attribute.type,\r\n        };\r\n      })\r\n      .filter((field) => field !== null)\r\n  ) as EditFieldLayout[][];\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * formatListLayout\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal\r\n * @description takes the complete configuration data, the schema & the components used in the schema and\r\n * formats a list view layout for the content-type. This is much simpler than the edit view layout as there\r\n * are less options to consider.\r\n */\r\nconst formatListLayout = (\r\n  data: LayoutData,\r\n  {\r\n    schemas,\r\n    schema,\r\n    components,\r\n  }: { schemas: Schema[]; schema?: Schema; components: ComponentsDictionary }\r\n): ListLayout => {\r\n  const listMetadatas = Object.entries(data.contentType.metadatas).reduce<ListLayout['metadatas']>(\r\n    (acc, [attribute, metadata]) => {\r\n      return {\r\n        ...acc,\r\n        [attribute]: metadata.list,\r\n      };\r\n    },\r\n    {}\r\n  );\r\n  /**\r\n   * The fields arranged by the panels, new panels are made for dynamic zones only.\r\n   */\r\n  const listAttributes = convertListLayoutToFieldLayouts(\r\n    data.contentType.layouts.list,\r\n    schema?.attributes,\r\n    listMetadatas,\r\n    { configurations: data.components, schemas: components },\r\n    schemas\r\n  );\r\n\r\n  return {\r\n    layout: listAttributes,\r\n    settings: { ...data.contentType.settings, displayName: schema?.info.displayName },\r\n    metadatas: listMetadatas,\r\n    options: {\r\n      ...schema?.options,\r\n      ...schema?.pluginOptions,\r\n      ...data.contentType.options,\r\n    },\r\n  };\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * convertListLayoutToFieldLayouts\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal\r\n * @description takes the columns from the list view configuration and formats them into a generic object\r\n * combinining metadata and attribute data.\r\n *\r\n * @note We do use this to reformat the list of strings when updating the displayed headers for the list view.\r\n */\r\nconst convertListLayoutToFieldLayouts = (\r\n  columns: LayoutData['contentType']['layouts']['list'],\r\n  attributes: Schema['attributes'] = {},\r\n  metadatas: ListLayout['metadatas'],\r\n  components?: {\r\n    configurations: Record<string, ComponentConfiguration>;\r\n    schemas: ComponentsDictionary;\r\n  },\r\n  schemas: Schema[] = []\r\n) => {\r\n  return columns\r\n    .map((name) => {\r\n      const attribute = attributes[name];\r\n\r\n      if (!attribute) {\r\n        return null;\r\n      }\r\n\r\n      const metadata = metadatas[name];\r\n\r\n      const settings: Partial<Settings> =\r\n        attribute.type === 'component' && components\r\n          ? components.configurations[attribute.component].settings\r\n          : {};\r\n\r\n      return {\r\n        attribute,\r\n        label: metadata.label ?? '',\r\n        mainField: getMainField(attribute, metadata.mainField || settings.mainField, {\r\n          schemas,\r\n          components: components?.schemas ?? {},\r\n        }),\r\n        name: name,\r\n        searchable: metadata.searchable ?? true,\r\n        sortable: metadata.sortable ?? true,\r\n      } satisfies ListFieldLayout;\r\n    })\r\n    .filter((field) => field !== null) as ListFieldLayout[];\r\n};\r\n\r\nexport {\r\n  useDocLayout,\r\n  useDocumentLayout,\r\n  convertListLayoutToFieldLayouts,\r\n  convertEditLayoutToFieldLayouts,\r\n  DEFAULT_SETTINGS,\r\n};\r\nexport type { EditLayout, EditFieldLayout, ListLayout, ListFieldLayout, UseDocumentLayout };\r\n", "import type { ComponentsDictionary, Schema } from '../hooks/useDocument';\r\nimport type { Schema as SchemaUtils } from '@strapi/types';\r\n\r\nconst checkIfAttributeIsDisplayable = (attribute: SchemaUtils.Attribute.AnyAttribute) => {\r\n  const { type } = attribute;\r\n\r\n  if (type === 'relation') {\r\n    return !attribute.relation.toLowerCase().includes('morph');\r\n  }\r\n\r\n  return !['json', 'dynamiczone', 'richtext', 'password', 'blocks'].includes(type) && !!type;\r\n};\r\n\r\ninterface MainField {\r\n  name: string;\r\n  type: SchemaUtils.Attribute.Kind | 'custom';\r\n}\r\n\r\n/**\r\n * @internal\r\n * @description given an attribute, content-type schemas & component schemas, find the mainField name & type.\r\n * If the attribute does not need a `mainField` then we return undefined. If we do not find the type\r\n * of the field, we assume it's a string #sensible-defaults\r\n */\r\nconst getMainField = (\r\n  attribute: SchemaUtils.Attribute.AnyAttribute,\r\n  mainFieldName: string | undefined,\r\n  { schemas, components }: { schemas: Schema[]; components: ComponentsDictionary }\r\n): MainField | undefined => {\r\n  if (!mainFieldName) {\r\n    return undefined;\r\n  }\r\n\r\n  const mainFieldType =\r\n    attribute.type === 'component'\r\n      ? components[attribute.component].attributes[mainFieldName].type\r\n      : // @ts-expect-error â€“ `targetModel` does exist on the attribute for a relation.\r\n        schemas.find((schema) => schema.uid === attribute.targetModel)?.attributes[mainFieldName]\r\n          .type;\r\n\r\n  return {\r\n    name: mainFieldName,\r\n    type: mainFieldType ?? 'string',\r\n  };\r\n};\r\n\r\nexport { checkIfAttributeIsDisplayable, getMainField };\r\nexport type { MainField };\r\n", "/**\r\n * This hook doesn't use a context provider because we fetch directly from the server,\r\n * this sounds expensive but actually, it's really not. Because we have redux-toolkit-query\r\n * being a cache layer so if nothing invalidates the cache, we don't fetch again.\r\n */\r\n\r\nimport * as React from 'react';\r\n\r\nimport {\r\n  useNotification,\r\n  useAPIErrorHandler,\r\n  useQueryParams,\r\n  FormErrors,\r\n  getYupValidationErrors,\r\n  useForm,\r\n} from '@strapi/admin/strapi-admin';\r\nimport { useIntl } from 'react-intl';\r\nimport { useParams } from 'react-router-dom';\r\nimport { ValidationError } from 'yup';\r\n\r\nimport { SINGLE_TYPES } from '../constants/collections';\r\nimport { type AnyData, transformDocument } from '../pages/EditView/utils/data';\r\nimport { createDefaultForm } from '../pages/EditView/utils/forms';\r\nimport { useGetDocumentQuery } from '../services/documents';\r\nimport { buildValidParams } from '../utils/api';\r\nimport { createYupSchema } from '../utils/validation';\r\n\r\nimport { useContentTypeSchema, ComponentsDictionary } from './useContentTypeSchema';\r\nimport { useDocumentLayout } from './useDocumentLayout';\r\n\r\nimport type { FindOne } from '../../../shared/contracts/collection-types';\r\nimport type { ContentType } from '../../../shared/contracts/content-types';\r\nimport type { Modules } from '@strapi/types';\r\n\r\ninterface UseDocumentArgs {\r\n  collectionType: string;\r\n  model: string;\r\n  documentId?: string;\r\n  params?: object;\r\n}\r\n\r\ntype UseDocumentOpts = Parameters<typeof useGetDocumentQuery>[1];\r\n\r\ntype Document = FindOne.Response['data'];\r\n\r\ntype Schema = ContentType;\r\n\r\ntype UseDocument = (\r\n  args: UseDocumentArgs,\r\n  opts?: UseDocumentOpts\r\n) => {\r\n  /**\r\n   * These are the schemas of the components used in the content type, organised\r\n   * by their uid.\r\n   */\r\n  components: ComponentsDictionary;\r\n  document?: Document;\r\n  meta?: FindOne.Response['meta'];\r\n  isLoading: boolean;\r\n  /**\r\n   * This is the schema of the content type, it is not the same as the layout.\r\n   */\r\n  schema?: Schema;\r\n  schemas?: Schema[];\r\n  hasError?: boolean;\r\n  refetch: () => void;\r\n  validate: (document: Document) => null | FormErrors;\r\n  /**\r\n   * Get the document's title\r\n   */\r\n  getTitle: (mainField: string) => string;\r\n  /**\r\n   * Get the initial form values for the document\r\n   */\r\n  getInitialFormValues: (isCreatingDocument?: boolean) => AnyData | undefined;\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * useDocument\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @alpha\r\n * @public\r\n * @description Returns a document based on the model, collection type & id passed as arguments.\r\n * Also extracts its schema from the redux cache to be used for creating a validation schema.\r\n * @example\r\n * ```tsx\r\n * const { id, model, collectionType } = useParams<{ id: string; model: string; collectionType: string }>();\r\n *\r\n * if(!model || !collectionType) return null;\r\n *\r\n * const { document, isLoading, validate } = useDocument({ documentId: id, model, collectionType, params: { locale: 'en-GB' } })\r\n * const { update } = useDocumentActions()\r\n *\r\n * const onSubmit = async (document: Document) => {\r\n *  const errors = validate(document);\r\n *\r\n *  if(errors) {\r\n *      // handle errors\r\n *  }\r\n *\r\n *  await update({ collectionType, model, id }, document)\r\n * }\r\n * ```\r\n *\r\n * @see {@link https://contributor.strapi.io/docs/core/content-manager/hooks/use-document} for more information\r\n */\r\nconst useDocument: UseDocument = (args, opts) => {\r\n  const { toggleNotification } = useNotification();\r\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\r\n  const { formatMessage } = useIntl();\r\n\r\n  const {\r\n    currentData: data,\r\n    isLoading: isLoadingDocument,\r\n    isFetching: isFetchingDocument,\r\n    error,\r\n    refetch,\r\n  } = useGetDocumentQuery(args, {\r\n    ...opts,\r\n    skip: (!args.documentId && args.collectionType !== SINGLE_TYPES) || opts?.skip,\r\n  });\r\n  const document = data?.data;\r\n  const meta = data?.meta;\r\n\r\n  const {\r\n    components,\r\n    schema,\r\n    schemas,\r\n    isLoading: isLoadingSchema,\r\n  } = useContentTypeSchema(args.model);\r\n  const isSingleType = schema?.kind === 'singleType';\r\n\r\n  const getTitle = (mainField: string) => {\r\n    // Always use mainField if it's not an id\r\n    if (mainField !== 'id' && document?.[mainField]) {\r\n      return document[mainField];\r\n    }\r\n\r\n    // When it's a singleType without a mainField, use the contentType displayName\r\n    if (isSingleType && schema?.info.displayName) {\r\n      return schema.info.displayName;\r\n    }\r\n\r\n    // Otherwise, use a fallback\r\n    return formatMessage({\r\n      id: 'content-manager.containers.untitled',\r\n      defaultMessage: 'Untitled',\r\n    });\r\n  };\r\n\r\n  React.useEffect(() => {\r\n    if (error) {\r\n      toggleNotification({\r\n        type: 'danger',\r\n        message: formatAPIError(error),\r\n      });\r\n    }\r\n  }, [toggleNotification, error, formatAPIError, args.collectionType]);\r\n\r\n  const validationSchema = React.useMemo(() => {\r\n    if (!schema) {\r\n      return null;\r\n    }\r\n\r\n    return createYupSchema(schema.attributes, components);\r\n  }, [schema, components]);\r\n\r\n  const validate = React.useCallback(\r\n    (document: Modules.Documents.AnyDocument): FormErrors | null => {\r\n      if (!validationSchema) {\r\n        throw new Error(\r\n          'There is no validation schema generated, this is likely due to the schema not being loaded yet.'\r\n        );\r\n      }\r\n\r\n      try {\r\n        validationSchema.validateSync(document, { abortEarly: false, strict: true });\r\n        return null;\r\n      } catch (error) {\r\n        if (error instanceof ValidationError) {\r\n          return getYupValidationErrors(error);\r\n        }\r\n\r\n        throw error;\r\n      }\r\n    },\r\n    [validationSchema]\r\n  );\r\n\r\n  /**\r\n   * Here we prepare the form for editing, we need to:\r\n   * - remove prohibited fields from the document (passwords | ADD YOURS WHEN THERES A NEW ONE)\r\n   * - swap out count objects on relations for empty arrays\r\n   * - set __temp_key__ on array objects for drag & drop\r\n   *\r\n   * We also prepare the form for new documents, so we need to:\r\n   * - set default values on fields\r\n   */\r\n  const getInitialFormValues = React.useCallback(\r\n    (isCreatingDocument: boolean = false) => {\r\n      if ((!document && !isCreatingDocument && !isSingleType) || !schema) {\r\n        return undefined;\r\n      }\r\n\r\n      /**\r\n       * Check that we have an ID so we know the\r\n       * document has been created in some way.\r\n       */\r\n      const form = document?.id ? document : createDefaultForm(schema, components);\r\n\r\n      return transformDocument(schema, components)(form);\r\n    },\r\n    [document, isSingleType, schema, components]\r\n  );\r\n\r\n  const isLoading = isLoadingDocument || isFetchingDocument || isLoadingSchema;\r\n  const hasError = !!error;\r\n\r\n  return {\r\n    components,\r\n    document,\r\n    meta,\r\n    isLoading,\r\n    hasError,\r\n    schema,\r\n    schemas,\r\n    validate,\r\n    getTitle,\r\n    getInitialFormValues,\r\n    refetch,\r\n  } satisfies ReturnType<UseDocument>;\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * useDoc\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal this hook uses the router to extract the model, collection type & id from the url.\r\n * therefore, it shouldn't be used outside of the content-manager because it won't work as intended.\r\n */\r\nconst useDoc = () => {\r\n  const { id, slug, collectionType, origin } = useParams<{\r\n    id: string;\r\n    origin: string;\r\n    slug: string;\r\n    collectionType: string;\r\n  }>();\r\n  const [{ query }] = useQueryParams();\r\n  const params = React.useMemo(() => buildValidParams(query), [query]);\r\n\r\n  if (!collectionType) {\r\n    throw new Error('Could not find collectionType in url params');\r\n  }\r\n\r\n  if (!slug) {\r\n    throw new Error('Could not find model in url params');\r\n  }\r\n\r\n  const document = useDocument(\r\n    { documentId: origin || id, model: slug, collectionType, params },\r\n    {\r\n      skip: id === 'create' || (!origin && !id && collectionType !== SINGLE_TYPES),\r\n    }\r\n  );\r\n\r\n  const returnId = origin || id === 'create' ? undefined : id;\r\n\r\n  return {\r\n    collectionType,\r\n    model: slug,\r\n    id: returnId,\r\n    ...document,\r\n  };\r\n};\r\n\r\n/**\r\n * @public\r\n * @experimental\r\n * Content manager context hooks for plugin development.\r\n * Make sure to use this hook inside the content manager.\r\n */\r\nconst useContentManagerContext = () => {\r\n  const {\r\n    collectionType,\r\n    model,\r\n    id,\r\n    components,\r\n    isLoading: isLoadingDoc,\r\n    schema,\r\n    schemas,\r\n  } = useDoc();\r\n\r\n  const layout = useDocumentLayout(model);\r\n\r\n  const form = useForm<unknown>('useContentManagerContext', (state) => state);\r\n\r\n  const isSingleType = collectionType === SINGLE_TYPES;\r\n  const slug = model;\r\n  const isCreatingEntry = id === 'create';\r\n\r\n  const {} = useContentTypeSchema();\r\n\r\n  const isLoading = isLoadingDoc || layout.isLoading;\r\n  const error = layout.error;\r\n\r\n  return {\r\n    error,\r\n    isLoading,\r\n\r\n    // Base metadata\r\n    model,\r\n    collectionType,\r\n    id,\r\n    slug,\r\n    isCreatingEntry,\r\n    isSingleType,\r\n    hasDraftAndPublish: schema?.options?.draftAndPublish ?? false,\r\n\r\n    // All schema infos\r\n    components,\r\n    contentType: schema,\r\n    contentTypes: schemas,\r\n\r\n    // Form state\r\n    form,\r\n\r\n    // layout infos\r\n    layout,\r\n  };\r\n};\r\n\r\nexport { useDocument, useDoc, useContentManagerContext };\r\nexport type { UseDocument, UseDocumentArgs, Document, Schema, ComponentsDictionary };\r\n", "import type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\r\nimport type { Schema } from '@strapi/types';\r\n\r\ntype AnyData = Omit<Document, 'id'>;\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * createDefaultForm\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @internal Using the content-type schema & the components dictionary of the content-type,\r\n * creates a form with pre-filled default values. This is used when creating a new entry.\r\n */\r\nconst createDefaultForm = (\r\n  contentType: Schema.Schema,\r\n  components: ComponentsDictionary = {}\r\n): AnyData => {\r\n  const traverseSchema = (attributes: Schema.Schema['attributes']): AnyData => {\r\n    return Object.entries(attributes).reduce<AnyData>((acc, [key, attribute]) => {\r\n      if ('default' in attribute) {\r\n        acc[key] = attribute.default;\r\n      } else if (attribute.type === 'component' && attribute.required) {\r\n        const defaultComponentForm = traverseSchema(components[attribute.component].attributes);\r\n\r\n        if (attribute.repeatable) {\r\n          acc[key] = attribute.min ? [...Array(attribute.min).fill(defaultComponentForm)] : [];\r\n        } else {\r\n          acc[key] = defaultComponentForm;\r\n        }\r\n      } else if (attribute.type === 'dynamiczone' && attribute.required) {\r\n        acc[key] = [];\r\n      }\r\n\r\n      return acc;\r\n    }, {});\r\n  };\r\n\r\n  return traverseSchema(contentType.attributes);\r\n};\r\n\r\nexport { createDefaultForm };\r\n", "import clone from 'lodash/clone';\r\nimport toPath from 'lodash/toPath';\r\n\r\n/**\r\n * Deeply get a value from an object via its path.\r\n */\r\nexport function getIn(obj: any, key: string | string[], def?: any, pathStartIndex: number = 0) {\r\n  const path = toPath(key);\r\n  while (obj && pathStartIndex < path.length) {\r\n    obj = obj[path[pathStartIndex++]];\r\n  }\r\n\r\n  // check if path is not in the end\r\n  if (pathStartIndex !== path.length && !obj) {\r\n    return def;\r\n  }\r\n\r\n  return obj === undefined ? def : obj;\r\n}\r\n\r\n/** @internal is the given object an Object? */\r\nexport const isObject = (obj: any): obj is object =>\r\n  obj !== null && typeof obj === 'object' && !Array.isArray(obj);\r\n\r\n/** @internal is the given object an integer? */\r\nexport const isInteger = (obj: any): boolean => String(Math.floor(Number(obj))) === obj;\r\n\r\n/**\r\n * Deeply set a value from in object via its path. If the value at `path`\r\n * has changed, return a shallow copy of obj with `value` set at `path`.\r\n * If `value` has not changed, return the original `obj`.\r\n *\r\n * Existing objects / arrays along `path` are also shallow copied. Sibling\r\n * objects along path retain the same internal js reference. Since new\r\n * objects / arrays are only created along `path`, we can test if anything\r\n * changed in a nested structure by comparing the object's reference in\r\n * the old and new object, similar to how russian doll cache invalidation\r\n * works.\r\n *\r\n * In earlier versions of this function, which used cloneDeep, there were\r\n * issues whereby settings a nested value would mutate the parent\r\n * instead of creating a new object. `clone` avoids that bug making a\r\n * shallow copy of the objects along the update path\r\n * so no object is mutated in place.\r\n *\r\n * Before changing this function, please read through the following\r\n * discussions.\r\n *\r\n * @see https://github.com/developit/linkstate\r\n * @see https://github.com/jaredpalmer/formik/pull/123\r\n */\r\nexport function setIn(obj: any, path: string, value: any): any {\r\n  const res: any = clone(obj); // this keeps inheritance when obj is a class\r\n  let resVal: any = res;\r\n  let i = 0;\r\n  const pathArray = toPath(path);\r\n\r\n  for (; i < pathArray.length - 1; i++) {\r\n    const currentPath: string = pathArray[i];\r\n    const currentObj: any = getIn(obj, pathArray.slice(0, i + 1));\r\n\r\n    if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {\r\n      resVal = resVal[currentPath] = clone(currentObj);\r\n    } else {\r\n      const nextPath: string = pathArray[i + 1];\r\n      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\r\n    }\r\n  }\r\n\r\n  // Return original object if new value is the same as current\r\n  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\r\n    return obj;\r\n  }\r\n\r\n  if (value === undefined) {\r\n    delete resVal[pathArray[i]];\r\n  } else {\r\n    resVal[pathArray[i]] = value;\r\n  }\r\n\r\n  // If the path array has a single element, the loop did not run.\r\n  // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.\r\n  if (i === 0 && value === undefined) {\r\n    delete res[pathArray[i]];\r\n  }\r\n\r\n  return res;\r\n}\r\n"],
  "mappings": "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",
  "names": ["_a", "pipe", "import_pipe", "attributes", "create", "pipe", "contentType", "components", "attributes", "_a", "React", "React", "document", "error", "toPath", "clone"]
}
