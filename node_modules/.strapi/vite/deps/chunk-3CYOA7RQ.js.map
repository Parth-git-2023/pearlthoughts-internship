{
  "version": 3,
  "sources": ["../../../../../packages/core/admin/admin/src/utils/cookies.ts", "../../../../../packages/core/admin/admin/src/utils/getFetchClient.ts", "../../../../../packages/core/admin/admin/src/utils/baseQuery.ts", "../../../../../packages/core/admin/admin/src/services/api.ts"],
  "sourcesContent": ["/**\r\n * Retrieves the value of a specified cookie.\r\n *\r\n * @param name - The name of the cookie to retrieve.\r\n * @returns The decoded cookie value if found, otherwise null.\r\n */\r\nexport const getCookieValue = (name: string): string | null => {\r\n  let result = null;\r\n  const cookieArray = document.cookie.split(';');\r\n  cookieArray.forEach((cookie) => {\r\n    const [key, value] = cookie.split('=').map((item) => item.trim());\r\n    if (key === name) {\r\n      result = decodeURIComponent(value);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\n/**\r\n * Sets a cookie with the given name, value, and optional expiration time.\r\n *\r\n * @param name - The name of the cookie.\r\n * @param value - The value of the cookie.\r\n * @param days - (Optional) Number of days until the cookie expires. If omitted, the cookie is a session cookie.\r\n */\r\nexport const setCookie = (name: string, value: string, days?: number): void => {\r\n  let expires = '';\r\n  if (days) {\r\n    const date = new Date();\r\n    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\r\n    expires = `; Expires=${date.toUTCString()}`;\r\n  }\r\n  document.cookie = `${name}=${encodeURIComponent(value)}; Path=/${expires}`;\r\n};\r\n\r\n/**\r\n * Deletes a cookie by setting its expiration date to a past date.\r\n *\r\n * @param name - The name of the cookie to delete.\r\n */\r\nexport const deleteCookie = (name: string): void => {\r\n  document.cookie = `${name}=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;`;\r\n};\r\n", "import pipe from 'lodash/fp/pipe';\r\nimport qs from 'qs';\r\n\r\nimport { getCookieValue } from './cookies';\r\n\r\nimport type { errors } from '@strapi/utils';\r\n\r\nexport type ApiError =\r\n  | errors.ApplicationError\r\n  | errors.ForbiddenError\r\n  | errors.NotFoundError\r\n  | errors.NotImplementedError\r\n  | errors.PaginationError\r\n  | errors.PayloadTooLargeError\r\n  | errors.PolicyError\r\n  | errors.RateLimitError\r\n  | errors.UnauthorizedError\r\n  | errors.ValidationError\r\n  | errors.YupValidationError;\r\n\r\nconst STORAGE_KEYS = {\r\n  TOKEN: 'jwtToken',\r\n  USER: 'userInfo',\r\n};\r\n\r\ntype FetchResponse<TData = any> = {\r\n  data: TData;\r\n  status?: number;\r\n};\r\n\r\ntype FetchOptions = {\r\n  params?: any;\r\n  signal?: AbortSignal;\r\n  headers?: Record<string, string>;\r\n  validateStatus?: ((status: number) => boolean) | null;\r\n};\r\n\r\ntype FetchConfig = {\r\n  signal?: AbortSignal;\r\n};\r\n\r\ninterface ErrorResponse {\r\n  data: {\r\n    data?: any;\r\n    error: ApiError & { status?: number };\r\n  };\r\n}\r\n\r\nclass FetchError extends Error {\r\n  public name: string;\r\n  public message: string;\r\n  public response?: ErrorResponse;\r\n  public code?: number;\r\n  public status?: number;\r\n\r\n  constructor(message: string, response?: ErrorResponse) {\r\n    super(message);\r\n    this.name = 'FetchError';\r\n    this.message = message;\r\n    this.response = response;\r\n    this.code = response?.data?.error?.status;\r\n    this.status = response?.data?.error?.status;\r\n\r\n    // Ensure correct stack trace in error object\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, FetchError);\r\n    }\r\n  }\r\n}\r\n\r\nconst isFetchError = (error: unknown): error is FetchError => {\r\n  return error instanceof FetchError;\r\n};\r\n\r\nconst getToken = (): string | null => {\r\n  const fromLocalStorage = localStorage.getItem(STORAGE_KEYS.TOKEN);\r\n  if (fromLocalStorage) {\r\n    return JSON.parse(fromLocalStorage);\r\n  }\r\n\r\n  const fromCookie = getCookieValue(STORAGE_KEYS.TOKEN);\r\n  return fromCookie ?? null;\r\n};\r\n\r\ntype FetchClient = {\r\n  get: <TData = any>(url: string, config?: FetchOptions) => Promise<FetchResponse<TData>>;\r\n  put: <TData = any, TSend = any>(\r\n    url: string,\r\n    data?: TSend,\r\n    config?: FetchOptions\r\n  ) => Promise<FetchResponse<TData>>;\r\n  post: <TData = any, TSend = any>(\r\n    url: string,\r\n    data?: TSend,\r\n    config?: FetchOptions\r\n  ) => Promise<FetchResponse<TData>>;\r\n  del: <TData = any>(url: string, config?: FetchOptions) => Promise<FetchResponse<TData>>;\r\n};\r\n\r\n/**\r\n * @public\r\n * @param {FetchConfig} [defaultOptions={}] - Fetch Configs.\r\n * @returns {FetchClient} A fetch client object with methods for making HTTP requests.\r\n * @description This is an abstraction around the native fetch exposed by a function. It provides a simple interface to handle API calls\r\n * to the Strapi backend.\r\n * @example\r\n * ```tsx\r\n * import { getFetchClient } from '@strapi/admin/admin';\r\n *\r\n * const myFunct = () => {\r\n *   const { get } = getFetchClient();\r\n *   const requestURL = \"/some-endpoint\";\r\n *\r\n *   const { data } = await get(requestURL);\r\n *\r\n *   return data;\r\n * };\r\n * ```\r\n */\r\nconst getFetchClient = (defaultOptions: FetchConfig = {}): FetchClient => {\r\n  const backendURL = window.strapi.backendURL;\r\n  const defaultHeader = {\r\n    Accept: 'application/json',\r\n    'Content-Type': 'application/json',\r\n    Authorization: `Bearer ${getToken()}`,\r\n  };\r\n\r\n  const isFormDataRequest = (body: unknown) => body instanceof FormData;\r\n  const addPrependingSlash = (url: string) => (url.charAt(0) !== '/' ? `/${url}` : url);\r\n\r\n  // This regular expression matches a string that starts with either \"http://\" or \"https://\" or any other protocol name in lower case letters, followed by \"://\" and ends with anything else\r\n  const hasProtocol = (url: string) => new RegExp('^(?:[a-z+]+:)?//', 'i').test(url);\r\n\r\n  // Check if the url has a prepending slash, if not add a slash\r\n  const normalizeUrl = (url: string) => (hasProtocol(url) ? url : addPrependingSlash(url));\r\n\r\n  // Add a response interceptor to return the response\r\n  const responseInterceptor = async <TData = any>(\r\n    response: Response,\r\n    validateStatus?: FetchOptions['validateStatus']\r\n  ): Promise<FetchResponse<TData>> => {\r\n    try {\r\n      const result = await response.json();\r\n\r\n      /**\r\n       * validateStatus allows us to customize when a response should throw an error\r\n       * In native Fetch API, a response is considered \"not ok\"\r\n       * when the status code falls in the 200 to 299 (inclusive) range\r\n       */\r\n      if (!response.ok && result.error && !validateStatus?.(response.status)) {\r\n        throw new FetchError(result.error.message, { data: result });\r\n      }\r\n\r\n      if (!response.ok && !validateStatus?.(response.status)) {\r\n        throw new FetchError('Unknown Server Error');\r\n      }\r\n\r\n      return { data: result };\r\n    } catch (error) {\r\n      if (error instanceof SyntaxError && response.ok) {\r\n        // Making sure that a SyntaxError doesn't throw if it's successful\r\n        return { data: [], status: response.status } as FetchResponse<any>;\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  };\r\n\r\n  const paramsSerializer =\r\n    <Param = unknown>(params?: Param) =>\r\n    (url: string) => {\r\n      if (params) {\r\n        if (typeof params === 'string') {\r\n          return `${url}?${params}`;\r\n        }\r\n\r\n        /**\r\n         * TODO V6: Encoding should be enabled in this step\r\n         * So the rest of the app doesn't have to worry about it,\r\n         * It's considered a breaking change because it impacts any API request, including the user's custom code\r\n         */\r\n        const serializedParams = qs.stringify(params, { encode: false });\r\n        return `${url}?${serializedParams}`;\r\n      }\r\n      return url;\r\n    };\r\n\r\n  const addBaseUrl = (url: Parameters<typeof fetch>[0]) => {\r\n    return `${backendURL}${url}`;\r\n  };\r\n\r\n  /**\r\n   * We use the factory method because the options\r\n   * are unique to the individual request\r\n   */\r\n  const makeCreateRequestUrl = (options?: FetchOptions) =>\r\n    pipe(normalizeUrl, addBaseUrl, paramsSerializer(options?.params));\r\n\r\n  const fetchClient: FetchClient = {\r\n    get: async <TData>(url: string, options?: FetchOptions): Promise<FetchResponse<TData>> => {\r\n      const headers = new Headers({\r\n        ...defaultHeader,\r\n        ...options?.headers,\r\n      });\r\n      /**\r\n       * this applies all our transformations to the URL\r\n       * - normalizing (making sure it has the correct slash)\r\n       * - appending our BaseURL which comes from the window.strapi object\r\n       * - serializing our params with QS\r\n       */\r\n      const createRequestUrl = makeCreateRequestUrl(options);\r\n      const response = await fetch(createRequestUrl(url), {\r\n        signal: options?.signal ?? defaultOptions.signal,\r\n        method: 'GET',\r\n        headers,\r\n      });\r\n\r\n      return responseInterceptor<TData>(response, options?.validateStatus);\r\n    },\r\n    post: async <TData, TSend = any>(\r\n      url: string,\r\n      data?: TSend,\r\n      options?: FetchOptions\r\n    ): Promise<FetchResponse<TData>> => {\r\n      const headers = new Headers({\r\n        ...defaultHeader,\r\n        ...options?.headers,\r\n      });\r\n\r\n      const createRequestUrl = makeCreateRequestUrl(options);\r\n\r\n      /**\r\n       * we have to remove the Content-Type value if it was a formData request\r\n       * the browser will automatically set the header value\r\n       */\r\n      if (isFormDataRequest(data)) {\r\n        headers.delete('Content-Type');\r\n      }\r\n\r\n      const response = await fetch(createRequestUrl(url), {\r\n        signal: options?.signal ?? defaultOptions.signal,\r\n        method: 'POST',\r\n        headers,\r\n        body: isFormDataRequest(data) ? (data as FormData) : JSON.stringify(data),\r\n      });\r\n      return responseInterceptor<TData>(response, options?.validateStatus);\r\n    },\r\n    put: async <TData, TSend = any>(\r\n      url: string,\r\n      data?: TSend,\r\n      options?: FetchOptions\r\n    ): Promise<FetchResponse<TData>> => {\r\n      const headers = new Headers({\r\n        ...defaultHeader,\r\n        ...options?.headers,\r\n      });\r\n\r\n      const createRequestUrl = makeCreateRequestUrl(options);\r\n\r\n      /**\r\n       * we have to remove the Content-Type value if it was a formData request\r\n       * the browser will automatically set the header value\r\n       */\r\n      if (isFormDataRequest(data)) {\r\n        headers.delete('Content-Type');\r\n      }\r\n\r\n      const response = await fetch(createRequestUrl(url), {\r\n        signal: options?.signal ?? defaultOptions.signal,\r\n        method: 'PUT',\r\n        headers,\r\n        body: isFormDataRequest(data) ? (data as FormData) : JSON.stringify(data),\r\n      });\r\n\r\n      return responseInterceptor<TData>(response, options?.validateStatus);\r\n    },\r\n    del: async <TData>(url: string, options?: FetchOptions): Promise<FetchResponse<TData>> => {\r\n      const headers = new Headers({\r\n        ...defaultHeader,\r\n        ...options?.headers,\r\n      });\r\n\r\n      const createRequestUrl = makeCreateRequestUrl(options);\r\n      const response = await fetch(createRequestUrl(url), {\r\n        signal: options?.signal ?? defaultOptions.signal,\r\n        method: 'DELETE',\r\n        headers,\r\n      });\r\n      return responseInterceptor<TData>(response, options?.validateStatus);\r\n    },\r\n  };\r\n\r\n  return fetchClient;\r\n};\r\n\r\nexport { getFetchClient, isFetchError, FetchError };\r\nexport type { FetchOptions, FetchResponse, FetchConfig, FetchClient, ErrorResponse };\r\n", "import { SerializedError } from '@reduxjs/toolkit';\r\nimport { BaseQueryFn } from '@reduxjs/toolkit/query';\r\n\r\nimport { getFetchClient, type FetchOptions, ApiError, isFetchError } from '../utils/getFetchClient';\r\n\r\ninterface QueryArguments {\r\n  url: string;\r\n  method?: 'GET' | 'POST' | 'DELETE' | 'PUT';\r\n  data?: unknown;\r\n  config?: FetchOptions;\r\n}\r\n\r\ninterface UnknownApiError {\r\n  name: 'UnknownError';\r\n  message: string;\r\n  details?: unknown;\r\n  status?: number;\r\n}\r\n\r\ntype BaseQueryError = ApiError | UnknownApiError;\r\n\r\nconst simpleQuery: BaseQueryFn<string | QueryArguments, unknown, BaseQueryError> = async (\r\n  query,\r\n  { signal }\r\n) => {\r\n  try {\r\n    const { get, post, del, put } = getFetchClient();\r\n\r\n    if (typeof query === 'string') {\r\n      const result = await get(query, { signal });\r\n      return { data: result.data };\r\n    } else {\r\n      const { url, method = 'GET', data, config } = query;\r\n\r\n      if (method === 'POST') {\r\n        const result = await post(url, data, {\r\n          ...config,\r\n          signal,\r\n        });\r\n        return { data: result.data };\r\n      }\r\n\r\n      if (method === 'DELETE') {\r\n        const result = await del(url, {\r\n          ...config,\r\n          signal,\r\n        });\r\n        return { data: result.data };\r\n      }\r\n\r\n      if (method === 'PUT') {\r\n        const result = await put(url, data, {\r\n          ...config,\r\n          signal,\r\n        });\r\n        return { data: result.data };\r\n      }\r\n\r\n      /**\r\n       * Default is GET.\r\n       */\r\n      const result = await get(url, {\r\n        ...config,\r\n        signal,\r\n      });\r\n      return { data: result.data };\r\n    }\r\n  } catch (err) {\r\n    // Handle error of type FetchError\r\n\r\n    if (isFetchError(err)) {\r\n      if (\r\n        typeof err.response?.data === 'object' &&\r\n        err.response?.data !== null &&\r\n        'error' in err.response?.data\r\n      ) {\r\n        /**\r\n         * This will most likely be ApiError\r\n         */\r\n        return { data: undefined, error: err.response?.data.error as any };\r\n      } else {\r\n        return {\r\n          data: undefined,\r\n          error: {\r\n            name: 'UnknownError',\r\n            message: err.message,\r\n            details: err.response,\r\n            status: err.status,\r\n          } as UnknownApiError,\r\n        };\r\n      }\r\n    }\r\n\r\n    const error = err as Error;\r\n    return {\r\n      data: undefined,\r\n      error: {\r\n        name: error.name,\r\n        message: error.message,\r\n        stack: error.stack,\r\n      } satisfies SerializedError,\r\n    };\r\n  }\r\n};\r\n\r\nconst fetchBaseQuery = () => simpleQuery;\r\n\r\nconst isBaseQueryError = (error: BaseQueryError | SerializedError): error is BaseQueryError => {\r\n  return error.name !== undefined;\r\n};\r\n\r\nexport { fetchBaseQuery, isBaseQueryError };\r\nexport type { BaseQueryError, UnknownApiError, QueryArguments };\r\n", "import { createApi } from '@reduxjs/toolkit/query/react';\r\n\r\nimport { fetchBaseQuery } from '../utils/baseQuery';\r\n\r\n/**\r\n * @public\r\n * @description This is the redux toolkit api for the admin panel, users\r\n * should use a combination of `enhanceEndpoints` to add their TagTypes\r\n * to utilise in their `injectEndpoints` construction for automatic cache\r\n * re-validation. We specifically do not store any tagTypes by default leaving\r\n * the API surface as small as possible. None of the data-fetching looks for the\r\n * StrapiApp are stored here either.\r\n */\r\nconst adminApi = createApi({\r\n  reducerPath: 'adminApi',\r\n  baseQuery: fetchBaseQuery(),\r\n  tagTypes: [],\r\n  endpoints: () => ({}),\r\n});\r\n\r\nexport { adminApi };\r\n"],
  "mappings": "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",
  "names": ["qs", "pipe", "result"]
}
