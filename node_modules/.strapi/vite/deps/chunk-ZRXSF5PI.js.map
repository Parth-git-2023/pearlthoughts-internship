{
  "version": 3,
  "sources": ["../../../../../packages/core/admin/admin/src/components/Form.tsx"],
  "sourcesContent": ["import * as React from 'react';\r\n\r\nimport {\r\n  Box,\r\n  type BoxProps,\r\n  Button,\r\n  Dialog,\r\n  useCallbackRef,\r\n  useComposedRefs,\r\n} from '@strapi/design-system';\r\nimport { WarningCircle } from '@strapi/icons';\r\nimport { generateNKeysBetween } from 'fractional-indexing';\r\nimport { produce } from 'immer';\r\nimport isEqual from 'lodash/isEqual';\r\nimport { useIntl, type MessageDescriptor, type PrimitiveType } from 'react-intl';\r\nimport { useBlocker } from 'react-router-dom';\r\n\r\nimport { getIn, setIn } from '../utils/objects';\r\n\r\nimport { createContext } from './Context';\r\n\r\nimport type {\r\n  InputProps as InputPropsImpl,\r\n  StringProps,\r\n  EnumerationProps,\r\n} from './FormInputs/types';\r\nimport type * as Yup from 'yup';\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * FormContext\r\n * -----------------------------------------------------------------------------------------------*/\r\ntype InputProps = InputPropsImpl | StringProps | EnumerationProps;\r\n\r\ninterface TranslationMessage extends MessageDescriptor {\r\n  values?: Record<string, PrimitiveType>;\r\n}\r\n\r\ninterface FormValues {\r\n  [field: string]: any;\r\n}\r\n\r\ninterface FormContextValue<TFormValues extends FormValues = FormValues>\r\n  extends FormState<TFormValues> {\r\n  disabled: boolean;\r\n  initialValues: TFormValues;\r\n  modified: boolean;\r\n  /**\r\n   * The default behaviour is to add the row to the end of the array, if you want to add it to a\r\n   * specific index you can pass the index.\r\n   */\r\n  addFieldRow: (field: string, value: any, addAtIndex?: number) => void;\r\n  moveFieldRow: (field: string, fromIndex: number, toIndex: number) => void;\r\n  onChange: (eventOrPath: React.ChangeEvent<any> | string, value?: any) => void;\r\n  /*\r\n   * The default behaviour is to remove the last row, if you want to remove a specific index you can\r\n   * pass the index.\r\n   */\r\n  removeFieldRow: (field: string, removeAtIndex?: number) => void;\r\n  resetForm: () => void;\r\n  setErrors: (errors: FormErrors<TFormValues>) => void;\r\n  setSubmitting: (isSubmitting: boolean) => void;\r\n  setValues: (values: TFormValues) => void;\r\n  validate: (\r\n    shouldSetErrors?: boolean,\r\n    options?: Record<string, string>\r\n  ) => Promise<\r\n    { data: TFormValues; errors?: never } | { data?: never; errors: FormErrors<TFormValues> }\r\n  >;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @description We use this just to warn people that they're using the useForm\r\n * methods outside of a Form component, but we don't want to throw an error\r\n * because otherwise the DocumentActions list cannot be rendered in our list-view.\r\n */\r\nconst ERR_MSG =\r\n  'The Form Component has not been initialised, ensure you are using this hook within a Form component';\r\n\r\nconst [FormProvider, useForm] = createContext<FormContextValue>('Form', {\r\n  disabled: false,\r\n  errors: {},\r\n  initialValues: {},\r\n  isSubmitting: false,\r\n  modified: false,\r\n  addFieldRow: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  moveFieldRow: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  onChange: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  removeFieldRow: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  resetForm: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  setErrors: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  setValues: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  setSubmitting: () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  validate: async () => {\r\n    throw new Error(ERR_MSG);\r\n  },\r\n  values: {},\r\n});\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * Form\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\ninterface FormHelpers<TFormValues extends FormValues = FormValues>\r\n  extends Pick<FormContextValue<TFormValues>, 'setErrors' | 'setValues' | 'resetForm'> {}\r\n\r\ninterface FormProps<TFormValues extends FormValues = FormValues>\r\n  extends Partial<Pick<FormContextValue<TFormValues>, 'disabled' | 'initialValues'>>,\r\n    Pick<BoxProps, 'width' | 'height'> {\r\n  children:\r\n    | React.ReactNode\r\n    | ((\r\n        props: Pick<\r\n          FormContextValue<TFormValues>,\r\n          | 'disabled'\r\n          | 'errors'\r\n          | 'isSubmitting'\r\n          | 'modified'\r\n          | 'values'\r\n          | 'resetForm'\r\n          | 'onChange'\r\n          | 'setErrors'\r\n        >\r\n      ) => React.ReactNode);\r\n  method: 'POST' | 'PUT';\r\n  onSubmit?: (values: TFormValues, helpers: FormHelpers<TFormValues>) => Promise<void> | void;\r\n  // TODO: type the return value for a validation schema func from Yup.\r\n  validationSchema?: Yup.AnySchema;\r\n  initialErrors?: FormErrors<TFormValues>;\r\n  // NOTE: we don't know what return type it can be here\r\n  validate?: (values: TFormValues, options: Record<string, string>) => Promise<any>;\r\n}\r\n\r\n/**\r\n * @alpha\r\n * @description A form component that handles form state, validation and submission.\r\n * It can additionally handle nested fields and arrays. To access the data you can either\r\n * use the generic useForm hook or the useField hook when providing the name of your field.\r\n */\r\nconst Form = React.forwardRef<HTMLFormElement, FormProps>(\r\n  ({ disabled = false, method, onSubmit, initialErrors, ...props }, ref) => {\r\n    const formRef = React.useRef<HTMLFormElement>(null!);\r\n    const initialValues = React.useRef(props.initialValues ?? {});\r\n    const [state, dispatch] = React.useReducer(reducer, {\r\n      errors: initialErrors ?? {},\r\n      isSubmitting: false,\r\n      values: props.initialValues ?? {},\r\n    });\r\n\r\n    React.useEffect(() => {\r\n      /**\r\n       * ONLY update the initialValues if the prop has changed.\r\n       */\r\n      if (!isEqual(initialValues.current, props.initialValues)) {\r\n        initialValues.current = props.initialValues ?? {};\r\n\r\n        dispatch({\r\n          type: 'SET_INITIAL_VALUES',\r\n          payload: props.initialValues ?? {},\r\n        });\r\n      }\r\n    }, [props.initialValues]);\r\n\r\n    const setErrors = React.useCallback((errors: FormErrors) => {\r\n      dispatch({\r\n        type: 'SET_ERRORS',\r\n        payload: errors,\r\n      });\r\n    }, []);\r\n\r\n    const setValues = React.useCallback((values: FormValues) => {\r\n      dispatch({\r\n        type: 'SET_VALUES',\r\n        payload: values,\r\n      });\r\n    }, []);\r\n\r\n    React.useEffect(() => {\r\n      if (Object.keys(state.errors).length === 0) return;\r\n\r\n      /**\r\n       * Small timeout to ensure the form has been\r\n       * rendered before we try to focus on the first\r\n       */\r\n      const ref = setTimeout(() => {\r\n        const [firstError] = formRef.current.querySelectorAll('[data-strapi-field-error]');\r\n\r\n        if (firstError) {\r\n          const errorId = firstError.getAttribute('id');\r\n          const formElementInError = formRef.current.querySelector(\r\n            `[aria-describedby=\"${errorId}\"]`\r\n          );\r\n\r\n          if (formElementInError && formElementInError instanceof HTMLElement) {\r\n            formElementInError.focus();\r\n          }\r\n        }\r\n      });\r\n\r\n      return () => clearTimeout(ref);\r\n    }, [state.errors]);\r\n\r\n    /**\r\n     * Uses the provided validation schema\r\n     */\r\n    const validate = React.useCallback(\r\n      async (shouldSetErrors: boolean = true, options: Record<string, string> = {}) => {\r\n        setErrors({});\r\n\r\n        if (!props.validationSchema && !props.validate) {\r\n          return { data: state.values };\r\n        }\r\n\r\n        try {\r\n          let data;\r\n          if (props.validationSchema) {\r\n            data = await props.validationSchema.validate(state.values, { abortEarly: false });\r\n          } else if (props.validate) {\r\n            data = await props.validate(state.values, options);\r\n          } else {\r\n            throw new Error('No validation schema or validate function provided');\r\n          }\r\n\r\n          return { data };\r\n        } catch (err) {\r\n          if (isErrorYupValidationError(err)) {\r\n            const errors = getYupValidationErrors(err);\r\n\r\n            if (shouldSetErrors) {\r\n              setErrors(errors);\r\n            }\r\n\r\n            return { errors };\r\n          } else {\r\n            // We throw any other errors\r\n            if (process.env.NODE_ENV !== 'production') {\r\n              console.warn(\r\n                `Warning: An unhandled error was caught during validation in <Form validationSchema />`,\r\n                err\r\n              );\r\n            }\r\n\r\n            throw err;\r\n          }\r\n        }\r\n      },\r\n      [props, setErrors, state.values]\r\n    );\r\n\r\n    const handleSubmit: React.FormEventHandler<HTMLFormElement> = async (e) => {\r\n      e.stopPropagation();\r\n      e.preventDefault();\r\n\r\n      if (!onSubmit) {\r\n        return;\r\n      }\r\n\r\n      dispatch({\r\n        type: 'SUBMIT_ATTEMPT',\r\n      });\r\n\r\n      try {\r\n        const { data, errors } = await validate();\r\n\r\n        if (errors) {\r\n          setErrors(errors);\r\n\r\n          throw new Error('Submission failed');\r\n        }\r\n\r\n        await onSubmit(data, {\r\n          setErrors,\r\n          setValues,\r\n          resetForm,\r\n        });\r\n\r\n        dispatch({\r\n          type: 'SUBMIT_SUCCESS',\r\n        });\r\n      } catch (err) {\r\n        dispatch({\r\n          type: 'SUBMIT_FAILURE',\r\n        });\r\n\r\n        if (err instanceof Error && err.message === 'Submission failed') {\r\n          return;\r\n        }\r\n      }\r\n    };\r\n\r\n    const modified = React.useMemo(\r\n      () => !isEqual(initialValues.current, state.values),\r\n      [state.values]\r\n    );\r\n\r\n    const handleChange: FormContextValue['onChange'] = useCallbackRef((eventOrPath, v) => {\r\n      if (typeof eventOrPath === 'string') {\r\n        dispatch({\r\n          type: 'SET_FIELD_VALUE',\r\n          payload: {\r\n            field: eventOrPath,\r\n            value: v,\r\n          },\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      const target = eventOrPath.target || eventOrPath.currentTarget;\r\n\r\n      const { type, name, id, value, options, multiple } = target;\r\n\r\n      const field = name || id;\r\n\r\n      if (!field && process.env.NODE_ENV !== 'production') {\r\n        console.warn(\r\n          `\\`onChange\\` was called with an event, but you forgot to pass a \\`name\\` or \\`id'\\` attribute to your input. The field to update cannot be determined`\r\n        );\r\n      }\r\n\r\n      /**\r\n       * Because we handle any field from this function, we run through a series\r\n       * of checks to understand how to use the value.\r\n       */\r\n      let val;\r\n\r\n      if (/number|range/.test(type)) {\r\n        const parsed = parseFloat(value);\r\n        // If the value isn't a number for whatever reason, don't let it through because that will break the API.\r\n        val = isNaN(parsed) ? '' : parsed;\r\n      } else if (/checkbox/.test(type)) {\r\n        // Get & invert the current value of the checkbox.\r\n        val = !getIn(state.values, field);\r\n      } else if (options && multiple) {\r\n        // This will handle native select elements incl. ones with mulitple options.\r\n        val = Array.from<HTMLOptionElement>(options)\r\n          .filter((el) => el.selected)\r\n          .map((el) => el.value);\r\n      } else {\r\n        // NOTE: reset value to null so it failes required checks.\r\n        // The API only considers a required field invalid if the value is null|undefined, to differentiate from min 1\r\n        if (value === '') {\r\n          val = null;\r\n        } else {\r\n          val = value;\r\n        }\r\n      }\r\n\r\n      if (field) {\r\n        dispatch({\r\n          type: 'SET_FIELD_VALUE',\r\n          payload: {\r\n            field,\r\n            value: val,\r\n          },\r\n        });\r\n      }\r\n    });\r\n\r\n    const addFieldRow: FormContextValue['addFieldRow'] = React.useCallback(\r\n      (field, value, addAtIndex) => {\r\n        dispatch({\r\n          type: 'ADD_FIELD_ROW',\r\n          payload: {\r\n            field,\r\n            value,\r\n            addAtIndex,\r\n          },\r\n        });\r\n      },\r\n      []\r\n    );\r\n\r\n    const removeFieldRow: FormContextValue['removeFieldRow'] = React.useCallback(\r\n      (field, removeAtIndex) => {\r\n        dispatch({\r\n          type: 'REMOVE_FIELD_ROW',\r\n          payload: {\r\n            field,\r\n            removeAtIndex,\r\n          },\r\n        });\r\n      },\r\n      []\r\n    );\r\n\r\n    const moveFieldRow: FormContextValue['moveFieldRow'] = React.useCallback(\r\n      (field, fromIndex, toIndex) => {\r\n        dispatch({\r\n          type: 'MOVE_FIELD_ROW',\r\n          payload: {\r\n            field,\r\n            fromIndex,\r\n            toIndex,\r\n          },\r\n        });\r\n      },\r\n      []\r\n    );\r\n\r\n    const resetForm: FormContextValue['resetForm'] = React.useCallback(() => {\r\n      dispatch({\r\n        type: 'RESET_FORM',\r\n        payload: {\r\n          errors: {},\r\n          isSubmitting: false,\r\n          values: initialValues.current,\r\n        },\r\n      });\r\n    }, []);\r\n\r\n    const setSubmitting = React.useCallback((isSubmitting: boolean) => {\r\n      dispatch({ type: 'SET_ISSUBMITTING', payload: isSubmitting });\r\n    }, []);\r\n\r\n    const composedRefs = useComposedRefs(formRef, ref);\r\n\r\n    return (\r\n      <Box\r\n        tag=\"form\"\r\n        ref={composedRefs}\r\n        method={method}\r\n        noValidate\r\n        onSubmit={handleSubmit}\r\n        width={props.width}\r\n        height={props.height}\r\n      >\r\n        <FormProvider\r\n          disabled={disabled}\r\n          onChange={handleChange}\r\n          initialValues={initialValues.current}\r\n          modified={modified}\r\n          addFieldRow={addFieldRow}\r\n          moveFieldRow={moveFieldRow}\r\n          removeFieldRow={removeFieldRow}\r\n          resetForm={resetForm}\r\n          setErrors={setErrors}\r\n          setValues={setValues}\r\n          setSubmitting={setSubmitting}\r\n          validate={validate}\r\n          {...state}\r\n        >\r\n          {typeof props.children === 'function'\r\n            ? props.children({\r\n                modified,\r\n                disabled,\r\n                onChange: handleChange,\r\n                ...state,\r\n                setErrors,\r\n                resetForm,\r\n              })\r\n            : props.children}\r\n        </FormProvider>\r\n      </Box>\r\n    );\r\n  }\r\n) as <TFormValues extends FormValues>(\r\n  p: FormProps<TFormValues> & { ref?: React.Ref<HTMLFormElement> }\r\n) => React.ReactElement; // we've cast this because we need the generic to infer the type of the form values.\r\n\r\n/**\r\n * @internal\r\n * @description Checks if the error is a Yup validation error.\r\n */\r\nconst isErrorYupValidationError = (err: any): err is Yup.ValidationError =>\r\n  typeof err === 'object' &&\r\n  err !== null &&\r\n  'name' in err &&\r\n  typeof err.name === 'string' &&\r\n  err.name === 'ValidationError';\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * getYupValidationErrors\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * @description handy utility to convert a yup validation error into a form\r\n * error object. To be used elsewhere.\r\n */\r\nconst getYupValidationErrors = (err: Yup.ValidationError): FormErrors => {\r\n  let errors: FormErrors = {};\r\n\r\n  if (err.inner) {\r\n    if (err.inner.length === 0) {\r\n      return setIn(errors, err.path!, err.message);\r\n    }\r\n    for (const error of err.inner) {\r\n      if (!getIn(errors, error.path!)) {\r\n        errors = setIn(errors, error.path!, error.message);\r\n      }\r\n    }\r\n  }\r\n\r\n  return errors;\r\n};\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * reducer\r\n * -----------------------------------------------------------------------------------------------*/\r\n\r\ntype FormErrors<TFormValues extends FormValues = FormValues> = {\r\n  // is it a repeatable component or dynamic zone?\r\n  [Key in keyof TFormValues]?: TFormValues[Key] extends any[]\r\n    ? TFormValues[Key][number] extends object\r\n      ? FormErrors<TFormValues[Key][number]>[] | string | string[]\r\n      : string // this would let us support errors for the dynamic zone or repeatable component not the components within.\r\n    : TFormValues[Key] extends object // is it a regular component?\r\n      ? FormErrors<TFormValues[Key]> // handles nested components\r\n      : string | TranslationMessage; // otherwise its just a field or a translation message.\r\n};\r\n\r\ninterface FormState<TFormValues extends FormValues = FormValues> {\r\n  /**\r\n   * TODO: make this a better type explaining errors could be nested because it follows the same\r\n   * structure as the values.\r\n   */\r\n  errors: FormErrors<TFormValues>;\r\n  isSubmitting: boolean;\r\n  values: TFormValues;\r\n}\r\n\r\ntype FormActions<TFormValues extends FormValues = FormValues> =\r\n  | { type: 'SUBMIT_ATTEMPT' }\r\n  | { type: 'SUBMIT_FAILURE' }\r\n  | { type: 'SUBMIT_SUCCESS' }\r\n  | { type: 'SET_FIELD_VALUE'; payload: { field: string; value: any } }\r\n  | { type: 'ADD_FIELD_ROW'; payload: { field: string; value: any; addAtIndex?: number } }\r\n  | { type: 'REMOVE_FIELD_ROW'; payload: { field: string; removeAtIndex?: number } }\r\n  | { type: 'MOVE_FIELD_ROW'; payload: { field: string; fromIndex: number; toIndex: number } }\r\n  | { type: 'SET_ERRORS'; payload: FormErrors<TFormValues> }\r\n  | { type: 'SET_ISSUBMITTING'; payload: boolean }\r\n  | { type: 'SET_INITIAL_VALUES'; payload: TFormValues }\r\n  | { type: 'SET_VALUES'; payload: TFormValues }\r\n  | { type: 'RESET_FORM'; payload: FormState<TFormValues> };\r\n\r\nconst reducer = <TFormValues extends FormValues = FormValues>(\r\n  state: FormState<TFormValues>,\r\n  action: FormActions<TFormValues>\r\n) =>\r\n  produce(state, (draft) => {\r\n    switch (action.type) {\r\n      case 'SET_INITIAL_VALUES':\r\n        // @ts-expect-error – TODO: figure out why this fails ts.\r\n        draft.values = action.payload;\r\n        break;\r\n      case 'SET_VALUES':\r\n        // @ts-expect-error – TODO: figure out why this fails ts.\r\n        draft.values = action.payload;\r\n        break;\r\n      case 'SUBMIT_ATTEMPT':\r\n        draft.isSubmitting = true;\r\n        break;\r\n      case 'SUBMIT_FAILURE':\r\n        draft.isSubmitting = false;\r\n        break;\r\n      case 'SUBMIT_SUCCESS':\r\n        draft.isSubmitting = false;\r\n        break;\r\n      case 'SET_FIELD_VALUE':\r\n        draft.values = setIn(state.values, action.payload.field, action.payload.value);\r\n        break;\r\n      case 'ADD_FIELD_ROW': {\r\n        /**\r\n         * TODO: add check for if the field is an array?\r\n         */\r\n        const currentField = getIn(state.values, action.payload.field, []) as Array<any>;\r\n\r\n        let position = action.payload.addAtIndex;\r\n\r\n        if (position === undefined) {\r\n          position = currentField.length;\r\n        } else if (position < 0) {\r\n          position = 0;\r\n        }\r\n\r\n        const [key] = generateNKeysBetween(\r\n          position > 0 ? currentField.at(position - 1)?.__temp_key__ : null,\r\n          currentField.at(position)?.__temp_key__,\r\n          1\r\n        );\r\n\r\n        draft.values = setIn(\r\n          state.values,\r\n          action.payload.field,\r\n          currentField.toSpliced(position, 0, {\r\n            ...action.payload.value,\r\n            __temp_key__: key,\r\n          })\r\n        );\r\n\r\n        break;\r\n      }\r\n      case 'MOVE_FIELD_ROW': {\r\n        const { field, fromIndex, toIndex } = action.payload;\r\n        /**\r\n         * TODO: add check for if the field is an array?\r\n         */\r\n        const currentField = [...(getIn(state.values, field, []) as Array<any>)];\r\n        const currentRow = currentField[fromIndex];\r\n\r\n        const startKey =\r\n          fromIndex > toIndex\r\n            ? currentField[toIndex - 1]?.__temp_key__\r\n            : currentField[toIndex]?.__temp_key__;\r\n        const endKey =\r\n          fromIndex > toIndex\r\n            ? currentField[toIndex]?.__temp_key__\r\n            : currentField[toIndex + 1]?.__temp_key__;\r\n        const [newKey] = generateNKeysBetween(startKey, endKey, 1);\r\n\r\n        currentField.splice(fromIndex, 1);\r\n        currentField.splice(toIndex, 0, { ...currentRow, __temp_key__: newKey });\r\n\r\n        draft.values = setIn(state.values, field, currentField);\r\n\r\n        break;\r\n      }\r\n      case 'REMOVE_FIELD_ROW': {\r\n        /**\r\n         * TODO: add check for if the field is an array?\r\n         */\r\n        const currentField = getIn(state.values, action.payload.field, []) as Array<any>;\r\n\r\n        let position = action.payload.removeAtIndex;\r\n\r\n        if (position === undefined) {\r\n          position = currentField.length - 1;\r\n        } else if (position < 0) {\r\n          position = 0;\r\n        }\r\n\r\n        /**\r\n         * filter out empty values from the array, the setIn function only deletes the value\r\n         * when we pass undefined as opposed to \"removing\" it from said array.\r\n         */\r\n        const newValue = setIn(currentField, position.toString(), undefined).filter(\r\n          (val: unknown) => val\r\n        );\r\n\r\n        draft.values = setIn(\r\n          state.values,\r\n          action.payload.field,\r\n          newValue.length > 0 ? newValue : []\r\n        );\r\n\r\n        break;\r\n      }\r\n      case 'SET_ERRORS':\r\n        if (!isEqual(state.errors, action.payload)) {\r\n          // @ts-expect-error – TODO: figure out why this fails a TS check.\r\n          draft.errors = action.payload;\r\n        }\r\n        break;\r\n      case 'SET_ISSUBMITTING':\r\n        draft.isSubmitting = action.payload;\r\n        break;\r\n      case 'RESET_FORM':\r\n        // @ts-expect-error – TODO: figure out why this fails ts.\r\n        draft.values = action.payload.values;\r\n        // @ts-expect-error – TODO: figure out why this fails ts.\r\n        draft.errors = action.payload.errors;\r\n        draft.isSubmitting = action.payload.isSubmitting;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  });\r\n\r\n/* -------------------------------------------------------------------------------------------------\r\n * useField\r\n * -----------------------------------------------------------------------------------------------*/\r\ninterface FieldValue<TValue = any> {\r\n  error?: string;\r\n  initialValue: TValue;\r\n  onChange: (eventOrPath: React.ChangeEvent<any> | string, value?: TValue) => void;\r\n  value: TValue;\r\n  rawError?: any;\r\n}\r\n\r\nfunction useField<TValue = any>(path: string): FieldValue<TValue | undefined> {\r\n  const { formatMessage } = useIntl();\r\n\r\n  const initialValue = useForm(\r\n    'useField',\r\n    (state) => getIn(state.initialValues, path) as FieldValue<TValue>['initialValue']\r\n  );\r\n\r\n  const value = useForm(\r\n    'useField',\r\n    (state) => getIn(state.values, path) as FieldValue<TValue>['value']\r\n  );\r\n\r\n  const handleChange = useForm('useField', (state) => state.onChange);\r\n\r\n  const rawError = useForm('useField', (state) => getIn(state.errors, path));\r\n\r\n  const error = useForm('useField', (state) => {\r\n    const error = getIn(state.errors, path);\r\n\r\n    if (isErrorMessageDescriptor(error)) {\r\n      const { values, ...message } = error;\r\n      return formatMessage(message, values);\r\n    }\r\n\r\n    return error;\r\n  });\r\n\r\n  return {\r\n    initialValue,\r\n    /**\r\n     * Errors can be a string, or a MessageDescriptor, so we need to handle both cases.\r\n     * If it's anything else, we don't return it.\r\n     */\r\n    rawError,\r\n    error: isErrorMessageDescriptor(error)\r\n      ? formatMessage(\r\n          {\r\n            id: error.id,\r\n            defaultMessage: error.defaultMessage,\r\n          },\r\n          error.values\r\n        )\r\n      : typeof error === 'string'\r\n        ? error\r\n        : undefined,\r\n    onChange: handleChange,\r\n    value: value,\r\n  };\r\n}\r\n\r\nconst isErrorMessageDescriptor = (object?: object): object is TranslationMessage => {\r\n  return (\r\n    typeof object === 'object' &&\r\n    object !== null &&\r\n    !Array.isArray(object) &&\r\n    'id' in object &&\r\n    'defaultMessage' in object\r\n  );\r\n};\r\n\r\n/**\r\n * Props for the Blocker component.\r\n * @param onProceed Function to be called when the user confirms the action that triggered the blocker.\r\n * @param onCancel Function to be called when the user cancels the action that triggered the blocker.\r\n */\r\ninterface BlockerProps {\r\n  onProceed?: () => void;\r\n  onCancel?: () => void;\r\n}\r\n/* -------------------------------------------------------------------------------------------------\r\n * Blocker\r\n * -----------------------------------------------------------------------------------------------*/\r\nconst Blocker = ({ onProceed = () => {}, onCancel = () => {} }: BlockerProps) => {\r\n  const { formatMessage } = useIntl();\r\n  const modified = useForm('Blocker', (state) => state.modified);\r\n  const isSubmitting = useForm('Blocker', (state) => state.isSubmitting);\r\n\r\n  const blocker = useBlocker(({ currentLocation, nextLocation }) => {\r\n    return (\r\n      !isSubmitting &&\r\n      modified &&\r\n      (currentLocation.pathname !== nextLocation.pathname ||\r\n        currentLocation.search !== nextLocation.search)\r\n    );\r\n  });\r\n\r\n  if (blocker.state === 'blocked') {\r\n    const handleCancel = (isOpen: boolean) => {\r\n      if (!isOpen) {\r\n        onCancel();\r\n        blocker.reset();\r\n      }\r\n    };\r\n\r\n    return (\r\n      <Dialog.Root open onOpenChange={handleCancel}>\r\n        <Dialog.Content>\r\n          <Dialog.Header>\r\n            {formatMessage({\r\n              id: 'app.components.ConfirmDialog.title',\r\n              defaultMessage: 'Confirmation',\r\n            })}\r\n          </Dialog.Header>\r\n          <Dialog.Body icon={<WarningCircle width=\"24px\" height=\"24px\" fill=\"danger600\" />}>\r\n            {formatMessage({\r\n              id: 'global.prompt.unsaved',\r\n              defaultMessage: 'You have unsaved changes, are you sure you want to leave?',\r\n            })}\r\n          </Dialog.Body>\r\n          <Dialog.Footer>\r\n            <Dialog.Cancel>\r\n              <Button variant=\"tertiary\">\r\n                {formatMessage({\r\n                  id: 'app.components.Button.cancel',\r\n                  defaultMessage: 'Cancel',\r\n                })}\r\n              </Button>\r\n            </Dialog.Cancel>\r\n            <Button\r\n              onClick={() => {\r\n                onProceed();\r\n                blocker.proceed();\r\n              }}\r\n              variant=\"danger\"\r\n            >\r\n              {formatMessage({\r\n                id: 'app.components.Button.confirm',\r\n                defaultMessage: 'Confirm',\r\n              })}\r\n            </Button>\r\n          </Dialog.Footer>\r\n        </Dialog.Content>\r\n      </Dialog.Root>\r\n    );\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport { Form, Blocker, useField, useForm, getYupValidationErrors };\r\nexport type {\r\n  FormErrors,\r\n  FormHelpers,\r\n  FormProps,\r\n  FormValues,\r\n  FormContextValue,\r\n  FormState,\r\n  FieldValue,\r\n  InputProps,\r\n};\r\n"],
  "mappings": "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",
  "names": ["isEqual", "ref", "error"]
}
